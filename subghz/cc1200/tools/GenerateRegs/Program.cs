using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Xml;
using System.Xml.Serialization;

var skipEnum = new HashSet<string>()
{
    { "CmixCfgValue" },
    { "ExtClockFreqValue" },
    { "LockTimeValue" },
    { "RampShapeValue" },
};

var knownVariantNames = new Dictionary<(string, int), string>
{
    [("AgcAskBwValue", 0b00)] = "AskBwScaleFactorEqualPoint28",
    [("AgcAskBwValue", 0b01)] = "AskBwScaleFactorEqualPoint18",
    [("AgcAskBwValue", 0b10)] = "AskBwScaleFactorEqualPoint15",
    [("AgcAskBwValue", 0b11)] = "AskBwScaleFactorEqualPoint14",
    [("AgcSyncBehaviourValue", 0b010)] = "NoAgcGainFreezeSlowMode",
    [("AgcSyncBehaviourValue", 0b110)] = "NoAgcGainFreezeSlowMode",
    [("CrcCfgValue", 0b01)] = "CrcEnabledPoly8005InitFFFF",
    [("CrcCfgValue", 0b10)] = "CrcEnabledPoly1021Init0000",
    [("CrcCfgValue", 0b11)] = "CrcEnabledPoly1021InvInit1D0F",
    [("DvgaGainValue", 0b00)] = "Db0",
    [("DvgaGainValue", 0b01)] = "DbMinus18",
    [("DvgaGainValue", 0b10)] = "Db6",
    [("DvgaGainValue", 0b11)] = "Db9",
    [("FocCfgValue", 0b01)] = "FocInFsEnabledFactorOneOver128",
    [("FocCfgValue", 0b10)] = "FocInFsEnabledFactorOneOver256",
    [("FocCfgValue", 0b11)] = "FocInFsEnabledFactorOneOver512",
    [("FsdBandselectValue", 0b0010)] = "Band820",
    [("FsdBandselectValue", 0b0100)] = "Band410",
    [("FsdBandselectValue", 0b0110)] = "Band273",
    [("FsdBandselectValue", 0b1000)] = "Band205",
    [("FsdBandselectValue", 0b1010)] = "Band164",
    [("FsdBandselectValue", 0b1011)] = "Band136",
    [("LengthConfigValue", 0b11)] = "VariablePacketLengthMode5Bits",
    [("NumPreambleValue", 0b0001)] = "Bits4",
    [("NumPreambleValue", 0b0011)] = "Bits12",
    [("PreambleWordValue", 0b00)] = "Pattern10101010",
    [("PreambleWordValue", 0b01)] = "Pattern01010101",
    [("PreambleWordValue", 0b10)] = "Pattern00110011",
    [("PreambleWordValue", 0b11)] = "Pattern11001100",
    [("RssiValidCntValue", 0b00)] = "Count1",
    [("RssiValidCntValue", 0b01)] = "Count2",
    [("RssiValidCntValue", 0b10)] = "Count5",
    [("RssiValidCntValue", 0b11)] = "Count9",
    [("TocLimitValue", 0b00)] = "Below2000Ppm",
    [("TransparentIntfactValue", 0b00)] = "OneTime",
    [("TransparentIntfactValue", 0b01)] = "TwoTimes",
    [("TransparentIntfactValue", 0b10)] = "FourTimes",
};

var filename = "C:\\Program Files (x86)\\Texas Instruments\\SmartRF Tools\\SmartRF Studio 7\\config\\xml\\cc1200\\register_definition.xml";
await using var file = File.OpenRead(filename);
using var streamReader = new StreamReader(file, Encoding.UTF8);
using var xmlReader = XmlReader.Create(streamReader, new XmlReaderSettings
{
    DtdProcessing = DtdProcessing.Ignore,
});
var serializer = new XmlSerializer(typeof(RegisterDefinition), new[]
{
    typeof(Register), typeof(Bitfield), typeof(Value)
});
var definition = (RegisterDefinition)serializer.Deserialize(xmlReader)!;
var trimDescriptionRegex = new Regex("<TABLE.*</TABLE>", RegexOptions.Singleline | RegexOptions.Compiled);

Console.WriteLine($$"""
    // This file is generated by the GenerateRegs tool - DO NOT EDIT

    #![allow(non_camel_case_types)]
    #![allow(clippy::derivable_impls)]

    use bitfield::bitfield;
    use core::mem::transmute;

    #[const_trait]
    pub trait Register: ~const From<u8> + ~const Default + Clone + Copy {
        const ADDRESS: u16;

        fn is_extended() -> bool {
            Self::ADDRESS > 0x7F
        }

        fn value(&self) -> u8;
    }

    """);

Console.WriteLine("pub mod pri {");
Console.WriteLine("    use super::*;");
foreach (var register in definition.Register.Where(x => Convert.ToInt32(x.Address[2..], 16) <= 0xFF))
{
    var writer = new StringBuilder();
    WriteRegister(writer, register);

    foreach (var line in writer.ToString().Split(Environment.NewLine))
    {
        Console.WriteLine("".PadLeft(4) + line);
    }
}
Console.WriteLine("}");
Console.WriteLine("");
Console.WriteLine("pub mod ext {");
Console.WriteLine("    use super::*;");
foreach (var register in definition.Register.Where(x => Convert.ToInt32(x.Address[2..], 16) > 0xFF))
{
    var writer = new StringBuilder();
    WriteRegister(writer, register);

    foreach (var line in writer.ToString().Split(Environment.NewLine))
    {
        if (line != "")
        {
            Console.Write("".PadLeft(4));
        }

        Console.WriteLine(line);
    }
}
Console.WriteLine("}");

void WriteRegister(StringBuilder writer, Register register)
{
    var structName = GetCamelCaseName(register.Name);
    var enums = new List<EnumGeneration>();

    var registerDescription = TrimDescription(register.Description);
    writer.AppendLine($$"""
    bitfield! {
        /// {{registerDescription}}
        ///
        #[derive(Clone, Copy)]
        pub struct {{structName}}(u8);
    """);
    foreach (var bitfield in register.Bitfield)
    {
        var getter = bitfield.Name.ToLowerInvariant();
        var setter = bitfield.Access == "R/W"
            ? "set_" + getter
            : null;
        var size = bitfield.Start - bitfield.Stop + 1;
        var range = size == 1
            ? bitfield.Start.ToString()
            : $"{bitfield.Start}, {bitfield.Stop}";

        writer.AppendLine();
        if (!string.IsNullOrEmpty(bitfield.Description))
        {
            using var lineReader = new StringReader(TrimDescription(bitfield.Description));
            string? line;
            while ((line = lineReader.ReadLine()) != null)
            {
                writer.AppendLine($"    /// {line}");
            }
        }

        var enumName = GetCamelCaseName(bitfield.Name) + "Value";
        var generateEnum = size > 1 && Math.Pow(2, size) == bitfield.Value.Count && !skipEnum.Contains(enumName);

        if (generateEnum)
        {
            enums.Add(new EnumGeneration(enumName, getter, setter, bitfield.Value));
        }
        else if (bitfield.Value.Any())
        {
            writer.AppendLine($"    ///");
            writer.AppendLine($"    /// # Values");
            writer.AppendLine($"    ///");

            if (size == 1)
            {
                foreach (var value in bitfield.Value)
                {
                    var variant = value.Number == "1" ? "true" : "false";
                    writer.AppendLine($"    /// - {variant}: {value.Brief}");
                }
            }
            else
            {
                foreach (var value in bitfield.Value)
                {
                    writer.AppendLine($"    /// - {value.Number}b: {value.Brief}");
                }
            }

            writer.AppendLine($"    ///");
            writer.AppendLine($"    /// The default value is {bitfield.Reset}");
        }

        if (generateEnum)
        {
            var bitsSetter = setter is null ? "_" : setter + "_bits";
            writer.AppendLine($"    {getter}_bits, {bitsSetter}: {range};");
        }
        else
        {
            writer.AppendLine($"    pub {getter}, {setter ?? "_"}: {range};");
        }
    }
    writer.AppendLine($"}}");
    writer.AppendLine();

    if (enums.Any())
    {
        writer.AppendLine($"impl {structName} {{");

        foreach (var @enum in enums)
        {
            writer.AppendLine($"    pub fn {@enum.Getter}(&self) -> {@enum.Name} {{");
            writer.AppendLine($"        unsafe {{ transmute(self.{@enum.Getter}_bits()) }}");
            writer.AppendLine($"    }}");

            if (@enum.Setter is not null)
            {
                writer.AppendLine();
                writer.AppendLine($"    pub fn {@enum.Setter}(&mut self, value: {@enum.Name}) {{");
                writer.AppendLine($"        self.{@enum.Setter}_bits(value as u8);");
                writer.AppendLine($"    }}");
            }
        }

        writer.AppendLine($"}}");
        writer.AppendLine();

        foreach (var @enum in enums)
        {
            writer.AppendLine($"#[derive(Debug, Clone, Copy, PartialEq)]");
            writer.AppendLine($"pub enum {@enum.Name} {{");

            var variantNames = @enum.Values.ToDictionary(x => x.NumberAsInt, x => GetEnumVariantName(@enum.Name, x));
            var nameCount = variantNames.Values.GroupBy(x => x).ToDictionary(x => x.Key, x => x.Count());

            foreach (var value in @enum.Values)
            {
                var variantName = variantNames[value.NumberAsInt];
                var count = nameCount[variantName];

                if (count > 1)
                {
                    variantName += "_" + value.Number;
                }

                var variantDescription = TrimDescription(value.Brief);
                writer.AppendLine($"    /// {variantDescription}");
                writer.AppendLine($"    {variantName} = 0b{value.Number},");
            }
            writer.AppendLine($"}}");
            writer.AppendLine();
        }
    }

    writer.AppendLine($$"""
        impl const Register for {{structName}} {
            const ADDRESS: u16 = {{register.Address}};

            fn value(&self) -> u8 {
                self.0
            }
        }

        """);

    writer.AppendLine($$"""
        impl const From<u8> for {{structName}} {
            fn from(value: u8) -> Self {
                Self(value)
            }
        }
        
        """);


    var defaultNumber = int.Parse(register.RegReset.Replace("0x", ""), NumberStyles.HexNumber);
    var defaultString = "0x" + Convert.ToString(defaultNumber, 16).PadLeft(2, '0');
    writer.AppendLine($$"""
        impl const Default for {{structName}} {
            fn default() -> Self {
                Self({{defaultString}})
            }
        }
        """);
}

static string GetCamelCaseName(string name)
{
    return string.Join("", name.Split('_').Select(x => x[0].ToString() + x.Substring(1).ToLowerInvariant()));
}

string TrimDescription(string description)
{
    description = description.ReplaceLineEndings().Trim();
    description = trimDescriptionRegex.Replace(description, "");
    description = description.Replace("\u0091", "").Replace("\u0092", "");
    return description;
}

string GetEnumVariantName(string enumName, Value value)
{
    if (value.Brief == "Reserved")
    {
        return "Reserved_" + value.Number.ToString();
    }

    if (knownVariantNames.TryGetValue((enumName, value.NumberAsInt), out var known))
    {
        return known;
    }


    var name = value.Brief;
    var index = name.IndexOfAny(new char[] { '.', '[', '(' });
    if (index != -1)
    {
        name = name.Substring(0, index);
    }

    var words = name
        .Replace('-', ' ')
        .Replace('/', ' ')
        .Replace(',', ' ')
        .Replace(">", "Above")
        .Replace("<", "Below")
        .Replace("=", "Equal")
        .Replace("%", "Pct")
        .Split(' ', StringSplitOptions.RemoveEmptyEntries)
        .ToList();

    if (words.Count == 2 && char.IsDigit(words[0][0]) && !char.IsDigit(words[1][0]))
    {
        words.Reverse();
    }

    name = string.Join("", words.Select(word => word.Substring(0, 1).ToUpperInvariant() + word.Substring(1).ToLowerInvariant()));
    return name;
}

public class EnumGeneration
{
    public string Name { get; }
    public string Getter { get; }
    public string? Setter { get; }
    public List<Value> Values { get; }

    public EnumGeneration(string name, string getter, string? setter, List<Value> values)
    {
        Name = name;
        Getter = getter;
        Setter = setter;
        Values = values;
    }
}

[XmlRoot("registerdefinition")]
public class RegisterDefinition
{
    public string DeviceName { get; set; } = default!;
    [XmlElement("Register")]
    public List<Register> Register { get; set; } = new();
}

public class Register
{
    public string Name { get; set; } = default!;
    public string Address { get; set; } = default!;
    public string Description { get; set; } = default!;
    [XmlElement("Bitfield")]
    public List<Bitfield> Bitfield { get; set; } = new();
    public string RegReset { get; set; } = default!;
}

public class Bitfield
{
    public string Name { get; set; } = default!;
    public int Start { get; set; }
    public int Stop { get; set; }
    public string Access { get; set; } = default!;
    public string Reset { get; set; } = default!;
    [XmlElement("Value")]
    public List<Value> Value { get; set; } = new();
    public string? Description { get; set; }
}

public class Value
{
    public string Number { get; set; } = default!;
    public int NumberAsInt => Convert.ToInt32(Number, 2);
    public string Brief { get; set; } = default!;
}
