using System.Globalization;
using System.Text.RegularExpressions;
using System.Xml;
using System.Xml.Serialization;

var skipEnum = new HashSet<string>()
{
    { "CmixCfgValue" },
    { "ExtClockFreqValue" },
    { "LockTimeValue" },
    { "RampShapeValue" },
};

var knownVariantNames = new Dictionary<(string, int), string>
{
    [("AgcAskBwValue", 0b00)] = "AskBwScaleFactorEqualPoint28",
    [("AgcAskBwValue", 0b01)] = "AskBwScaleFactorEqualPoint18",
    [("AgcAskBwValue", 0b10)] = "AskBwScaleFactorEqualPoint15",
    [("AgcAskBwValue", 0b11)] = "AskBwScaleFactorEqualPoint14",
    [("AgcSyncBehaviourValue", 0b010)] = "NoAgcGainFreezeSlowMode",
    [("AgcSyncBehaviourValue", 0b110)] = "NoAgcGainFreezeSlowMode",
    [("CrcCfgValue", 0b01)] = "CrcEnabledPoly8005InitFFFF",
    [("CrcCfgValue", 0b10)] = "CrcEnabledPoly1021Init0000",
    [("CrcCfgValue", 0b11)] = "CrcEnabledPoly1021InvInit1D0F",
    [("DvgaGainValue", 0b00)] = "Db0",
    [("DvgaGainValue", 0b01)] = "DbMinus18",
    [("DvgaGainValue", 0b10)] = "Db6",
    [("DvgaGainValue", 0b11)] = "Db9",
    [("FocCfgValue", 0b01)] = "FocInFsEnabledFactorOneOver128",
    [("FocCfgValue", 0b10)] = "FocInFsEnabledFactorOneOver256",
    [("FocCfgValue", 0b11)] = "FocInFsEnabledFactorOneOver512",
    [("FsdBandselectValue", 0b0010)] = "Band820",
    [("FsdBandselectValue", 0b0100)] = "Band410",
    [("FsdBandselectValue", 0b0110)] = "Band273",
    [("FsdBandselectValue", 0b1000)] = "Band205",
    [("FsdBandselectValue", 0b1010)] = "Band164",
    [("FsdBandselectValue", 0b1011)] = "Band136",
    [("LengthConfigValue", 0b11)] = "VariablePacketLengthMode5Bits",
    [("NumPreambleValue", 0b0001)] = "Bits4",
    [("NumPreambleValue", 0b0011)] = "Bits12",
    [("PreambleWordValue", 0b00)] = "Pattern10101010",
    [("PreambleWordValue", 0b01)] = "Pattern01010101",
    [("PreambleWordValue", 0b10)] = "Pattern00110011",
    [("PreambleWordValue", 0b11)] = "Pattern11001100",
    [("RssiValidCntValue", 0b00)] = "Count1",
    [("RssiValidCntValue", 0b01)] = "Count2",
    [("RssiValidCntValue", 0b10)] = "Count5",
    [("RssiValidCntValue", 0b11)] = "Count9",
    [("TocLimitValue", 0b00)] = "Below2000Ppm",
    [("TransparentIntfactValue", 0b00)] = "OneTime",
    [("TransparentIntfactValue", 0b01)] = "TwoTimes",
    [("TransparentIntfactValue", 0b10)] = "FourTimes",
};

var serializer = new XmlSerializer(typeof(RegisterDefinition), new[]
{
    typeof(Register), typeof(Bitfield), typeof(Value)
});

await using var file = File.OpenRead("C:\\Program Files (x86)\\Texas Instruments\\SmartRF Tools\\SmartRF Studio 7\\config\\xml\\cc1200\\register_definition.xml");
using var reader = XmlReader.Create(file, new XmlReaderSettings
{
    DtdProcessing = DtdProcessing.Ignore
});
var definition = (RegisterDefinition)serializer.Deserialize(reader)!;
var trimDescriptionRegex = new Regex("<TABLE.*</TABLE>", RegexOptions.Singleline | RegexOptions.Compiled);

Console.WriteLine($"// This file is generated by the generate_regs.cs tool - DO NOT EDIT");
Console.WriteLine();
Console.WriteLine($"#![allow(non_camel_case_types)]");
Console.WriteLine($"#![allow(clippy::derivable_impls)]");
Console.WriteLine();
Console.WriteLine($"use bitfield::bitfield;");
Console.WriteLine($"use core::mem::transmute;");
Console.WriteLine();

foreach (var register in definition.Register)
{
    var structName = GetCamelCaseName(register.Name);
    var enums = new List<EnumGeneration>();

    Console.WriteLine($"bitfield! {{");
    Console.WriteLine($"    /// {register.Description}");
    Console.WriteLine($"    ///");
    Console.WriteLine($"    /// # Address");
    Console.WriteLine($"    ///");
    Console.WriteLine($"    /// The address of this register is {register.Address}");
    Console.WriteLine($"    #[derive(Clone, Copy)]");
    Console.WriteLine($"    pub struct {structName}(u8);");
    foreach (var bitfield in register.Bitfield)
    {
        var getter = bitfield.Name.ToLowerInvariant();
        var setter = bitfield.Access == "R/W"
            ? "set_" + getter
            : null;
        var size = bitfield.Start - bitfield.Stop + 1;
        var range = size == 1
            ? bitfield.Start.ToString()
            : $"{bitfield.Start}, {bitfield.Stop}";

        Console.WriteLine();
        if (!string.IsNullOrEmpty(bitfield.Description))
        {
            var description = bitfield.Description.ReplaceLineEndings().Trim();
            description = trimDescriptionRegex.Replace(description, "");

            using var lineReader = new StringReader(description);
            string? line;
            while ((line = lineReader.ReadLine()) != null)
            {
                Console.WriteLine($"    /// {line}");
            }
        }

        var enumName = GetCamelCaseName(bitfield.Name) + "Value";
        var generateEnum = size > 1 && Math.Pow(2, size) == bitfield.Value.Count && !skipEnum.Contains(enumName);

        if (generateEnum)
        {
            enums.Add(new EnumGeneration(enumName, getter, setter, bitfield.Value));
        }
        else if (bitfield.Value.Any())
        {
            Console.WriteLine($"    ///");
            Console.WriteLine($"    /// # Values");
            Console.WriteLine($"    ///");

            if (size == 1)
            {
                foreach (var value in bitfield.Value)
                {
                    var variant = value.Number == "1" ? "true" : "false";
                    Console.WriteLine($"    /// - {variant}: {value.Brief}");
                }
            }
            else
            {
                foreach (var value in bitfield.Value)
                {
                    Console.WriteLine($"    /// - {value.Number}b: {value.Brief}");
                }
            }

            Console.WriteLine($"    ///");
            Console.WriteLine($"    /// The default value is {bitfield.Reset}");
        }


        if (generateEnum)
        {
            var bitsSetter = setter is null ? "_" : setter + "_bits";
            Console.WriteLine($"    {getter}_bits, {bitsSetter}: {range};");
        }
        else
        {
            Console.WriteLine($"    pub {getter}, {setter ?? "_"}: {range};");
        }
    }
    Console.WriteLine($"}}");
    Console.WriteLine();

    if (enums.Any())
    {
        Console.WriteLine($"impl {structName} {{");

        foreach (var @enum in enums)
        {
            Console.WriteLine($"    pub fn {@enum.Getter}(&self) -> {@enum.Name} {{");
            Console.WriteLine($"        unsafe {{ transmute(self.{@enum.Getter}_bits()) }}");
            Console.WriteLine($"    }}");

            if (@enum.Setter is not null)
            {
                Console.WriteLine();
                Console.WriteLine($"    pub fn {@enum.Setter}(&mut self, value: {@enum.Name}) {{");
                Console.WriteLine($"        self.{@enum.Setter}_bits(value as u8);");
                Console.WriteLine($"    }}");
            }
        }

        Console.WriteLine($"}}");
        Console.WriteLine();

        foreach (var @enum in enums)
        {
            Console.WriteLine($"#[derive(Debug, Clone, Copy, PartialEq)]");
            Console.WriteLine($"pub enum {@enum.Name} {{");

            var variantNames = @enum.Values.ToDictionary(x => x.NumberAsInt, x => GetEnumVariantName(@enum.Name, x));
            var nameCount = variantNames.Values.GroupBy(x => x).ToDictionary(x => x.Key, x => x.Count());

            foreach (var value in @enum.Values)
            {
                var variantName = variantNames[value.NumberAsInt];
                var count = nameCount[variantName];

                if (count > 1)
                {
                    variantName += "_" + value.Number;
                }

                Console.WriteLine($"    /// {value.Brief}");
                Console.WriteLine($"    {variantName} = 0b{value.Number},");
            }
            Console.WriteLine($"}}");
            Console.WriteLine();
        }
    }


    var defaultNumber = int.Parse(register.RegReset.Replace("0x", ""), NumberStyles.HexNumber);
    var defaultString = "0x" + Convert.ToString(defaultNumber, 16).PadLeft(2, '0');
    Console.WriteLine($"impl Default for {structName} {{");
    Console.WriteLine($"    fn default() -> Self {{");
    Console.WriteLine($"        Self({defaultString})");
    Console.WriteLine($"    }}");
    Console.WriteLine($"}}");
    Console.WriteLine();
}

static string GetCamelCaseName(string name)
{
    return string.Join("", name.Split('_').Select(x => x[0].ToString() + x.Substring(1).ToLowerInvariant()));
}

string GetEnumVariantName(string enumName, Value value)
{
    if (value.Brief == "Reserved")
    {
        return "Reserved_" + value.Number.ToString();
    }

    if (knownVariantNames.TryGetValue((enumName, value.NumberAsInt), out var known))
    {
        return known;
    }


    var name = value.Brief;
    var index = name.IndexOfAny(new char[] { '.', '[', '(' });
    if (index != -1)
    {
        name = name.Substring(0, index);
    }

    var words = name
        .Replace('-', ' ')
        .Replace('/', ' ')
        .Replace(',', ' ')
        .Replace(">", "Above")
        .Replace("<", "Below")
        .Replace("=", "Equal")
        .Replace("%", "Pct")
        .Split(' ', StringSplitOptions.RemoveEmptyEntries)
        .ToList();

    if (words.Count == 2 && char.IsDigit(words[0][0]) && !char.IsDigit(words[1][0]))
    {
        words.Reverse();
    }

    name = string.Join("", words.Select(word => word.Substring(0, 1).ToUpperInvariant() + word.Substring(1).ToLowerInvariant()));
    return name;
}

public class EnumGeneration
{
    public string Name { get; }
    public string Getter { get; }
    public string? Setter { get; }
    public List<Value> Values { get; }

    public EnumGeneration(string name, string getter, string? setter, List<Value> values)
    {
        Name = name;
        Getter = getter;
        Setter = setter;
        Values = values;
    }
}

[XmlRoot("registerdefinition")]
public class RegisterDefinition
{
    public string DeviceName { get; set; } = default!;
    [XmlElement("Register")]
    public List<Register> Register { get; set; } = new();
}

public class Register
{
    public string Name { get; set; } = default!;
    public string Address { get; set; } = default!;
    public string? Description { get; set; }
    [XmlElement("Bitfield")]
    public List<Bitfield> Bitfield { get; set; } = new();
    public string RegReset { get; set; } = default!;
}

public class Bitfield
{
    public string Name { get; set; } = default!;
    public int Start { get; set; }
    public int Stop { get; set; }
    public string Access { get; set; } = default!;
    public string Reset { get; set; } = default!;
    [XmlElement("Value")]
    public List<Value> Value { get; set; } = new();
    public string? Description { get; set; }
}

public class Value
{
    public string Number { get; set; } = default!;
    public int NumberAsInt => Convert.ToInt32(Number, 2);
    public string Brief { get; set; } = default!;
}
