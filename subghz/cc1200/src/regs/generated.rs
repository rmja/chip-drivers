// This file is generated by the GenerateRegs tool - DO NOT EDIT

#![allow(non_camel_case_types)]
#![allow(clippy::derivable_impls)]

use bitfield::bitfield;
use core::mem::transmute;

#[const_trait]
pub trait Register: Clone + Copy + Default + From<u8> {
    const ADDRESS: RegisterAddress;

    fn value(&self) -> u8;
}

#[derive(Clone, Copy, Debug, PartialEq, PartialOrd)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub struct RegisterAddress(pub(crate) u16);

pub mod pri {
    use super::*;
    bitfield! {
        /// GPIO3 IO Pin Configuration
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Iocfg3(u8);

        /// Analog transfer enable
        ///
        /// # Values
        ///
        /// - false: Standard digital pad
        /// - true: Pad in analog mode (digital GPIO input and output disabled)
        ///
        /// The default value is 0x00
        pub gpio3_atran, set_gpio3_atran: 7;

        /// Invert output enable
        ///
        /// # Values
        ///
        /// - false: Invert output disabled
        /// - true: Invert output enable
        ///
        /// The default value is 0x00
        pub gpio3_inv, set_gpio3_inv: 6;

        /// Output selection. Default: PKT_SYNC_RXTX
        pub gpio3_cfg, set_gpio3_cfg: 5, 0;
    }

    impl const Register for Iocfg3 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x00);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Iocfg3 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Iocfg3 {
        fn default() -> Self {
            Self(0x06)
        }
    }

    impl core::fmt::Debug for Iocfg3 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Iocfg3 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// GPIO2 IO Pin Configuration
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Iocfg2(u8);

        /// Analog transfer enable. Refer to IOCFG3
        pub gpio2_atran, set_gpio2_atran: 7;

        /// Invert output enable. Refer to IOCFG3
        pub gpio2_inv, set_gpio2_inv: 6;

        /// Output selection. Default: PKT_CRC_OK
        pub gpio2_cfg, set_gpio2_cfg: 5, 0;
    }

    impl const Register for Iocfg2 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x01);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Iocfg2 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Iocfg2 {
        fn default() -> Self {
            Self(0x07)
        }
    }

    impl core::fmt::Debug for Iocfg2 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Iocfg2 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// GPIO1 IO Pin Configuration
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Iocfg1(u8);

        /// Analog transfer enable. Refer to IOCFG3
        pub gpio1_atran, set_gpio1_atran: 7;

        /// Invert output enable. Refer to IOCFG3
        pub gpio1_inv, set_gpio1_inv: 6;

        /// Output selection. Default: HIGHZ. Note that GPIO1 is shared with the SPI and act as SO when CSn is asserted (active low). The system must ensure pull up/down on this pin
        pub gpio1_cfg, set_gpio1_cfg: 5, 0;
    }

    impl const Register for Iocfg1 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x02);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Iocfg1 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Iocfg1 {
        fn default() -> Self {
            Self(0x30)
        }
    }

    impl core::fmt::Debug for Iocfg1 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Iocfg1 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// GPIO0 IO Pin Configuration
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Iocfg0(u8);

        /// Analog transfer enable. Refer to IOCFG3
        pub gpio0_atran, set_gpio0_atran: 7;

        /// Invert output enable. Refer to IOCFG3
        pub gpio0_inv, set_gpio0_inv: 6;

        /// Output selection. Default: EXT_OSC_EN
        pub gpio0_cfg, set_gpio0_cfg: 5, 0;
    }

    impl const Register for Iocfg0 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x03);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Iocfg0 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Iocfg0 {
        fn default() -> Self {
            Self(0x3c)
        }
    }

    impl core::fmt::Debug for Iocfg0 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Iocfg0 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Sync Word Configuration [31:24]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Sync3(u8);

        /// Sync word [31:24]
        pub sync31_24, set_sync31_24: 7, 0;
    }

    impl const Register for Sync3 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x04);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Sync3 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Sync3 {
        fn default() -> Self {
            Self(0x93)
        }
    }

    impl core::fmt::Debug for Sync3 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Sync3 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Sync Word Configuration [23:16]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Sync2(u8);

        /// Sync word [23:16]
        pub sync23_16, set_sync23_16: 7, 0;
    }

    impl const Register for Sync2 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x05);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Sync2 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Sync2 {
        fn default() -> Self {
            Self(0x0b)
        }
    }

    impl core::fmt::Debug for Sync2 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Sync2 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Sync Word Configuration [15:8]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Sync1(u8);

        /// Sync word [15:8]
        pub sync15_8, set_sync15_8: 7, 0;
    }

    impl const Register for Sync1 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x06);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Sync1 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Sync1 {
        fn default() -> Self {
            Self(0x51)
        }
    }

    impl core::fmt::Debug for Sync1 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Sync1 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Sync Word Configuration [7:0]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Sync0(u8);

        /// Sync Word [7:0]
        pub sync7_0, set_sync7_0: 7, 0;
    }

    impl const Register for Sync0 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x07);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Sync0 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Sync0 {
        fn default() -> Self {
            Self(0xde)
        }
    }

    impl core::fmt::Debug for Sync0 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Sync0 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Sync Word Detection Configuration Reg. 1
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct SyncCfg1(u8);

        /// Sync word configuration. When SYNC_MODE = 000b, all samples (noise or data) received after RX mode is entered will either be put in the RX FIFO or output on a GPIO configured as SERIAL_RX. Note that when 4'ary modulation is used the sync word uses 2'ary modulation (the symbol rate is kept the same)
        sync_mode_bits, set_sync_mode_bits: 7, 5;

        /// Soft decision sync word threshold. A sync word is accepted when the calculated sync word qualifier value (PQT_SYNC_ERR.SYNC_ERROR) is less than SYNC_THR/2). A low threshold value means a strict sync word qualifier (sync word must be of high quality to be accepted) while a high threshold value will accept sync word of a poorer quality (increased probability of detecting false sync words)
        pub sync_thr, set_sync_thr: 4, 0;
    }

    impl SyncCfg1 {
        pub fn sync_mode(&self) -> SyncModeValue {
            unsafe { transmute(self.sync_mode_bits()) }
        }

        pub fn set_sync_mode(&mut self, value: SyncModeValue) {
            self.set_sync_mode_bits(value as u8);
        }
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum SyncModeValue {
        /// No sync word
        NoSyncWord = 0b000,
        /// 11 bits [SYNC15_8[2:0]:SYNC7_0]
        Bits11 = 0b001,
        /// 16 bits [SYNC15_8:SYNC7_0]
        Bits16 = 0b010,
        /// 18 bits [SYNC23_16[1:0]:SYNC15_8:SYNC7_0]
        Bits18 = 0b011,
        /// 24 bits [SYNC23_16:SYNC15_8:SYNC7_0]
        Bits24 = 0b100,
        /// 32 bits [SYNC31_24:SYNC23_16:SYNC15_8:SYNC7_0]
        Bits32 = 0b101,
        /// 16H bits [SYNC31_24:SYNC23_16]
        Bits16h = 0b110,
        /// 16D bits (DualSync search). When this setting is used in TX mode [SYNC15_8:SYNC7_0] is transmitted
        Bits16d = 0b111,
    }

    impl const Register for SyncCfg1 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x08);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for SyncCfg1 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for SyncCfg1 {
        fn default() -> Self {
            Self(0xaa)
        }
    }

    impl core::fmt::Debug for SyncCfg1 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for SyncCfg1 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Sync Word Detection Configuration Reg. 0
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct SyncCfg0(u8);

        pub sync_cfg0_not_used, _: 7, 6;

        /// Auto clear enable. Auto clear of symbol rate offset estimate when TOC_CFG.TOC_LIMIT != 0 and MDMCFG1.CARRIER_SENSE_GATE = 1. The  symbol rate offset estimate will be cleared when CARRIER_SENSE is de-asserted. Auto clear of IQIC coefficient when IQIC.IQIC_EN = 1. The receiver image compensation coefficient is cleared when the image signal dissappears
        ///
        /// # Values
        ///
        /// - false: Auto clear disabled
        /// - true: Auto clear enabled
        ///
        /// The default value is 0x00
        pub auto_clear, set_auto_clear: 5;

        /// Receiver configuration limitation. The decimation factor is given by CHAN_BW.ADC_CIC_DECFACT. When this bit is set, RX filter BW must be less than 1500 kHz.
        /// When RX_CONFIG_LIMITATION = 1 the AGC_CFG1.AGC_WIN_SIZE should be incremented by 1 and the wait time between AGC gain adjustment programmed through AGC_CFG1.AGC_SETTLE_WAIT should be doubled.
        ///
        /// # Values
        ///
        /// - false: Symbol Rate <= RX Filter BW/2 = f_xosc/(Decimation Factor*CHAN_BW.BB_CIC_DECFACT*4)[Hz]
        /// - true: Symbol Rate <= RX Filter BW = f_xosc/(Decimation Factor*CHAN_BW.BB_CIC_DECFACT*2)[Hz]
        ///
        /// The default value is 0x00
        pub rx_config_limitation, set_rx_config_limitation: 4;

        /// PQT gating enable
        ///
        /// # Values
        ///
        /// - false: PQT gating enable
        /// - true: PQT gating enabled. The demodulator will not start to look for a sync word before a preamble is detected (i.e. PQT_REACHED is asserted). The preamble detector must be enabled for this feature to work (PREAMBLE_CFG0.PQT_EN = 1)
        ///
        /// The default value is 0x00
        pub pqt_gating_en, set_pqt_gating_en: 3;

        /// External sync detect can be used in blind mode to make the receiver change modem parameters after a sync word has been detected by the MCU. GPIO2 needs to be configured as SYNC_DETECT (IOCFG2.GPIO2_CFG = HIGHZ (48)) and the MCU should set this input when a sync word is detected. This will make the receiver switch modem parameters from sync search settings to packet receive settings similar to what is done in FIFO mode/normal mode
        pub ext_sync_detect, set_ext_sync_detect: 2;

        /// Strict sync word bit check. This feature is useful in cases where the sync word has weak correlation properties (level 3 is the strictest sync check)
        strict_sync_check_bits, set_strict_sync_check_bits: 1, 0;
    }

    impl SyncCfg0 {
        pub fn strict_sync_check(&self) -> StrictSyncCheckValue {
            unsafe { transmute(self.strict_sync_check_bits()) }
        }

        pub fn set_strict_sync_check(&mut self, value: StrictSyncCheckValue) {
            self.set_strict_sync_check_bits(value as u8);
        }
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum StrictSyncCheckValue {
        /// Strict sync word check level 1
        StrictSyncWordCheckLevel1 = 0b00,
        /// Strict sync word check level 2
        StrictSyncWordCheckLevel2 = 0b01,
        /// Strict sync word check level 3
        StrictSyncWordCheckLevel3 = 0b10,
        /// Strict sync word check disabled
        StrictSyncWordCheckDisabled = 0b11,
    }

    impl const Register for SyncCfg0 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x09);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for SyncCfg0 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for SyncCfg0 {
        fn default() -> Self {
            Self(0x03)
        }
    }

    impl core::fmt::Debug for SyncCfg0 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for SyncCfg0 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Frequency Deviation Configuration
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct DeviationM(u8);

        /// Frequency deviation (mantissa part)<BR/>
        /// DEV_E > 0 => f_dev = f_xosc*(256+DEV_M)*2^DEV_E/2^22 [Hz]<BR/>
        /// DEV_E = 0 => f_dev = f_xosc*DEV_M/2^21 [Hz]
        pub dev_m, set_dev_m: 7, 0;
    }

    impl const Register for DeviationM {
        const ADDRESS: RegisterAddress = RegisterAddress(0x0A);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for DeviationM {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for DeviationM {
        fn default() -> Self {
            Self(0x06)
        }
    }

    impl core::fmt::Debug for DeviationM {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for DeviationM {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Modulation Format and Frequency Deviation Configuration
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct ModcfgDevE(u8);

        /// Modem mode configuration
        pub modem_mode, set_modem_mode: 7, 6;

        /// Modulation format
        mod_format_bits, set_mod_format_bits: 5, 3;

        /// Frequency deviation (exponent part). See DEVIATION_M
        pub dev_e, set_dev_e: 2, 0;
    }

    impl ModcfgDevE {
        pub fn mod_format(&self) -> ModFormatValue {
            unsafe { transmute(self.mod_format_bits()) }
        }

        pub fn set_mod_format(&mut self, value: ModFormatValue) {
            self.set_mod_format_bits(value as u8);
        }
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum ModFormatValue {
        /// 2-FSK
        Fsk2 = 0b000,
        /// 2-GFSK
        Gfsk2 = 0b001,
        /// Reserved
        Reserved_010 = 0b010,
        /// ASK/OOK
        AskOok = 0b011,
        /// 4-FSK
        Fsk4 = 0b100,
        /// 4-GFSK
        Gfsk4 = 0b101,
        /// Reserved
        Reserved_110 = 0b110,
        /// Reserved
        Reserved_111 = 0b111,
    }

    impl const Register for ModcfgDevE {
        const ADDRESS: RegisterAddress = RegisterAddress(0x0B);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for ModcfgDevE {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for ModcfgDevE {
        fn default() -> Self {
            Self(0x03)
        }
    }

    impl core::fmt::Debug for ModcfgDevE {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for ModcfgDevE {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Digital DC Removal Configuration
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct DcfiltCfg(u8);

        pub dcfilt_cfg_not_used, _: 7;

        /// DC filter override
        ///
        /// # Values
        ///
        /// - false: DC filter algorithm estimates and compensates for DC error
        /// - true: Manual DC compensation through registers DCFILTOFFSET_I1, DCFILTOFFSET_I0, DCFILTOFFSET_Q1, and DCFILTOFFSET_Q0
        ///
        /// The default value is 0x01
        pub dcfilt_freeze_coeff, set_dcfilt_freeze_coeff: 6;

        /// Settling period of high pass DC filter after AGC adjustment<BR/>
        /// Sample Rate = f_xosc/Decimation Factor [Hz]<BR/>
        /// The decimation factor is 12, 24, or 48, depending on the CHAN_BW.ADC_CIC_DECFACT setting
        dcfilt_bw_settle_bits, set_dcfilt_bw_settle_bits: 5, 3;

        /// Cut-off frequency (f_Cut_Off ) of high pass DC filter<BR/>
        /// DCFILT_BW = 0 - 011b:<BR/>
        /// f_Cut_Off_DC_filter ~= f_xosc/(Decimation Factor*2^(DCFILT_BW+3)) [Hz]<BR/>
        /// DCFILT_BW = 110b - 111b:<BR/>
        /// f_Cut_Off_DC_filter ~= f_xosc/(Decimation Factor*2^(2*DCFILT_BW)) [Hz]<BR/>
        /// The decimation factor is 12, 24, or48, depending on the CHAN_BW.ADC_CIC_DECFACT setting
        pub dcfilt_bw, set_dcfilt_bw: 2, 0;
    }

    impl DcfiltCfg {
        pub fn dcfilt_bw_settle(&self) -> DcfiltBwSettleValue {
            unsafe { transmute(self.dcfilt_bw_settle_bits()) }
        }

        pub fn set_dcfilt_bw_settle(&mut self, value: DcfiltBwSettleValue) {
            self.set_dcfilt_bw_settle_bits(value as u8);
        }
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum DcfiltBwSettleValue {
        /// 8 samples
        Samples8 = 0b000,
        /// 16 samples
        Samples16 = 0b001,
        /// 32 samples
        Samples32 = 0b010,
        /// 64 samples
        Samples64 = 0b011,
        /// 128 samples
        Samples128_100 = 0b100,
        /// 128 samples
        Samples128_101 = 0b101,
        /// 128 samples
        Samples128_110 = 0b110,
        /// 128 samples
        Samples128_111 = 0b111,
    }

    impl const Register for DcfiltCfg {
        const ADDRESS: RegisterAddress = RegisterAddress(0x0C);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for DcfiltCfg {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for DcfiltCfg {
        fn default() -> Self {
            Self(0x4c)
        }
    }

    impl core::fmt::Debug for DcfiltCfg {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for DcfiltCfg {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Preamble Length Configuration Reg. 1
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct PreambleCfg1(u8);

        pub preamble_cfg1_not_used, _: 7, 6;

        /// Sets the minimum number of preamble bits to be transmitted
        num_preamble_bits, set_num_preamble_bits: 5, 2;

        /// Preamble byte configuration. PREAMBLE_WORD determines how a preamble byte looks like. Note that when 4'ary modulation is used the preamble uses 2'are modulation (the baud rate is kept the same)
        preamble_word_bits, set_preamble_word_bits: 1, 0;
    }

    impl PreambleCfg1 {
        pub fn num_preamble(&self) -> NumPreambleValue {
            unsafe { transmute(self.num_preamble_bits()) }
        }

        pub fn set_num_preamble(&mut self, value: NumPreambleValue) {
            self.set_num_preamble_bits(value as u8);
        }
        pub fn preamble_word(&self) -> PreambleWordValue {
            unsafe { transmute(self.preamble_word_bits()) }
        }

        pub fn set_preamble_word(&mut self, value: PreambleWordValue) {
            self.set_preamble_word_bits(value as u8);
        }
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum NumPreambleValue {
        /// No preamble
        NoPreamble = 0b0000,
        /// 0.5 byte
        Bits4 = 0b0001,
        /// 1 byte
        Byte1 = 0b0010,
        /// 1.5 bytes
        Bits12 = 0b0011,
        /// 2 bytes
        Bytes2 = 0b0100,
        /// 3 bytes
        Bytes3 = 0b0101,
        /// 4 bytes
        Bytes4 = 0b0110,
        /// 5 bytes
        Bytes5 = 0b0111,
        /// 6 bytes
        Bytes6 = 0b1000,
        /// 7 bytes
        Bytes7 = 0b1001,
        /// 8 bytes
        Bytes8 = 0b1010,
        /// 12 bytes
        Bytes12 = 0b1011,
        /// 24 bytes
        Bytes24 = 0b1100,
        /// 30 bytes
        Bytes30 = 0b1101,
        /// Reserved
        Reserved_1110 = 0b1110,
        /// Reserved
        Reserved_1111 = 0b1111,
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum PreambleWordValue {
        /// 10101010 (0xAA)
        Pattern10101010 = 0b00,
        /// 01010101 (0x55)
        Pattern01010101 = 0b01,
        /// 00110011 (0x33)
        Pattern00110011 = 0b10,
        /// 11001100 (0xCC)
        Pattern11001100 = 0b11,
    }

    impl const Register for PreambleCfg1 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x0D);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for PreambleCfg1 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for PreambleCfg1 {
        fn default() -> Self {
            Self(0x14)
        }
    }

    impl core::fmt::Debug for PreambleCfg1 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for PreambleCfg1 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Preamble Detection Configuration Reg. 0
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct PreambleCfg0(u8);

        /// Preamble detection enable
        ///
        /// # Values
        ///
        /// - false: Preamble detection disabled
        /// - true: Preamble detection enabled
        ///
        /// The default value is 0x01
        pub pqt_en, set_pqt_en: 7;

        /// PQT start-up timer. PQT_VALID_TIMEOUT sets the number of symbols that must be received before PQT_VALID is asserted
        pqt_valid_timeout_bits, set_pqt_valid_timeout_bits: 6, 4;

        /// Soft Decision PQT. A preamble is detected when the calculated preamble qualifier value (PQT_SYNC_ERR.PQT_ERROR) is less than PQT. A low threshold value means a strict preamble qualifier (preamble must be of high quality to be accepted) while a high threshold value will accept preamble of a poorer quality (increased probability of detecting false preamble)
        pub pqt, set_pqt: 3, 0;
    }

    impl PreambleCfg0 {
        pub fn pqt_valid_timeout(&self) -> PqtValidTimeoutValue {
            unsafe { transmute(self.pqt_valid_timeout_bits()) }
        }

        pub fn set_pqt_valid_timeout(&mut self, value: PqtValidTimeoutValue) {
            self.set_pqt_valid_timeout_bits(value as u8);
        }
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum PqtValidTimeoutValue {
        /// 11 symbols
        Symbols11 = 0b000,
        /// 12 symbols
        Symbols12 = 0b001,
        /// 13 symbols
        Symbols13 = 0b010,
        /// 14 symbols
        Symbols14 = 0b011,
        /// 15 symbols
        Symbols15 = 0b100,
        /// 17 symbols
        Symbols17 = 0b101,
        /// 24 symbols
        Symbols24 = 0b110,
        /// 32 symbols
        Symbols32 = 0b111,
    }

    impl const Register for PreambleCfg0 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x0E);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for PreambleCfg0 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for PreambleCfg0 {
        fn default() -> Self {
            Self(0xda)
        }
    }

    impl core::fmt::Debug for PreambleCfg0 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for PreambleCfg0 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Digital Image Channel Compensation Configuration
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Iqic(u8);

        /// IQ image compensation enable. When this bit is set the following must be true:<BR/>
        /// f_IF > RX Filter BW<BR/>
        /// (see IF_MIX_CFGCMIX_CFG for how to program f_IF)
        ///
        /// # Values
        ///
        /// - false: IQ image compensation disabled
        /// - true: IQ image compensation enabled
        ///
        /// The default value is 0x01
        pub iqic_en, set_iqic_en: 7;

        /// IQIC update coefficients enable
        ///
        /// # Values
        ///
        /// - false: IQIC update coefficients disabled (IQIE_I1, IQIE_I0, IQIE_Q1, IQIE_Q0 registers are not updated)
        /// - true: IQIC update coefficients enabled (IQIE_I1, IQIE_I0, IQIE_Q1, IQIE_Q0 registers are updated)
        ///
        /// The default value is 0x01
        pub iqic_update_coeff_en, set_iqic_update_coeff_en: 6;

        /// IQIC block length when settling. The IQIC module will do a coarse estimation of IQ imbalance coefficients during settling mode. Long block length increases settling time and improves image rejection
        iqic_blen_settle_bits, set_iqic_blen_settle_bits: 5, 4;

        /// IQIC block length. Long block length increases settling time and improves image rejection
        iqic_blen_bits, set_iqic_blen_bits: 3, 2;

        /// IQIC image channel level threshold. Image rejection will be activated when image carrier is present. The IQIC image channel level threshold is an image carrier detector. High threshold imply that image carrier must be high to enable IQIC compensation module
        iqic_imgch_level_thr_bits, set_iqic_imgch_level_thr_bits: 1, 0;
    }

    impl Iqic {
        pub fn iqic_blen_settle(&self) -> IqicBlenSettleValue {
            unsafe { transmute(self.iqic_blen_settle_bits()) }
        }

        pub fn set_iqic_blen_settle(&mut self, value: IqicBlenSettleValue) {
            self.set_iqic_blen_settle_bits(value as u8);
        }
        pub fn iqic_blen(&self) -> IqicBlenValue {
            unsafe { transmute(self.iqic_blen_bits()) }
        }

        pub fn set_iqic_blen(&mut self, value: IqicBlenValue) {
            self.set_iqic_blen_bits(value as u8);
        }
        pub fn iqic_imgch_level_thr(&self) -> IqicImgchLevelThrValue {
            unsafe { transmute(self.iqic_imgch_level_thr_bits()) }
        }

        pub fn set_iqic_imgch_level_thr(&mut self, value: IqicImgchLevelThrValue) {
            self.set_iqic_imgch_level_thr_bits(value as u8);
        }
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum IqicBlenSettleValue {
        /// 8 samples
        Samples8 = 0b00,
        /// 32 samples
        Samples32 = 0b01,
        /// 128 samples
        Samples128 = 0b10,
        /// 256 samples
        Samples256 = 0b11,
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum IqicBlenValue {
        /// 8 samples
        Samples8 = 0b00,
        /// 32 samples
        Samples32 = 0b01,
        /// 128 samples
        Samples128 = 0b10,
        /// 256 samples
        Samples256 = 0b11,
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum IqicImgchLevelThrValue {
        /// > 256
        Above256 = 0b00,
        /// > 512
        Above512 = 0b01,
        /// > 1024
        Above1024 = 0b10,
        /// > 2048
        Above2048 = 0b11,
    }

    impl const Register for Iqic {
        const ADDRESS: RegisterAddress = RegisterAddress(0x0F);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Iqic {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Iqic {
        fn default() -> Self {
            Self(0xc4)
        }
    }

    impl core::fmt::Debug for Iqic {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Iqic {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Channel Filter Configuration
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct ChanBw(u8);

        /// ADC_CIC_DECFACT is a table index which programs the first decimation filter and program the RX filter bandwidth. ADC_CIC_DECFACT table index:
        adc_cic_decfact_bits, set_adc_cic_decfact_bits: 7, 6;

        /// BB_CIC_DECFACT configures the RX filter BW by changing decimation factor in the second decimation filter
        pub bb_cic_decfact, set_bb_cic_decfact: 5, 0;
    }

    impl ChanBw {
        pub fn adc_cic_decfact(&self) -> AdcCicDecfactValue {
            unsafe { transmute(self.adc_cic_decfact_bits()) }
        }

        pub fn set_adc_cic_decfact(&mut self, value: AdcCicDecfactValue) {
            self.set_adc_cic_decfact_bits(value as u8);
        }
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum AdcCicDecfactValue {
        /// Decimation factor 12
        DecimationFactor12 = 0b00,
        /// Decimation factor 24
        DecimationFactor24 = 0b01,
        /// Decimation factor 48
        DecimationFactor48 = 0b10,
        /// Reserved
        Reserved_11 = 0b11,
    }

    impl const Register for ChanBw {
        const ADDRESS: RegisterAddress = RegisterAddress(0x10);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for ChanBw {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for ChanBw {
        fn default() -> Self {
            Self(0x94)
        }
    }

    impl core::fmt::Debug for ChanBw {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for ChanBw {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// General Modem Parameter Configuration Reg. 1
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Mdmcfg1(u8);

        /// When CARRIER_SENSE_GATE is 1, the demodulator will not start to look for a sync word before CARRIER_SENSE is asserted
        ///
        /// # Values
        ///
        /// - false: Search for sync word regardless of CS
        /// - true: Do not start sync search before CARRIER_SENSE is asserted
        ///
        /// The default value is 0x00
        pub carrier_sense_gate, set_carrier_sense_gate: 7;

        /// FIFO enable. Specifies if data to/from modem will be passed through the FIFOs or directly to the serial pin
        ///
        /// # Values
        ///
        /// - false: Data in/out through the serial pin(s) (the FIFOs are bypassed)
        /// - true: Data in/out through the FIFOs
        ///
        /// The default value is 0x01
        pub fifo_en, set_fifo_en: 6;

        /// Manchester mode enable. Manchester encoding/decoding is only applicable to payload data including optional CRC. Manchester encoding/decoding is not supported for 4-(G)FSK
        ///
        /// # Values
        ///
        /// - false: NRZ
        /// - true: Manchester encoding/decoding
        ///
        /// The default value is 0x00
        pub manchester_en, set_manchester_en: 5;

        /// Invert data enable. Invert payload data stream in RX and TX (only applicable to payload data including optional CRC)
        ///
        /// # Values
        ///
        /// - false: Invert data disabled
        /// - true: Invert data enabled
        ///
        /// The default value is 0x00
        pub invert_data_en, set_invert_data_en: 4;

        /// Collision detect enable. After a sync word is detected (SYNC_EVENT asserted), the receiver will always receive a packet. If collision detection is enabled, the receiver will continue to search for preamble. If a new preamble is found (PQT_REACHED asserted) and the RSSI has increased  10 or 16 dB during packet reception (depending on AGC_CFG1.RSSI_STEP_THR) a collision is detected and the COLLISION_FOUND flag will be asserted
        ///
        /// # Values
        ///
        /// - false: Collision detect disabled
        /// - true: collision detect enabled
        ///
        /// The default value is 0x00
        pub collision_detect_en, set_collision_detect_en: 3;

        /// Fixed DVGA gain configuration. The DVGA configuration has impact on the RSSI  offset
        dvga_gain_bits, set_dvga_gain_bits: 2, 1;

        /// Configure the number of active receive channels. If this bit is set the power consumption will be reduced but the sensitivity level will be reduced by ~3 dB. Image rejection will not work
        ///
        /// # Values
        ///
        /// - false: IQ-channels
        /// - true: Only I-channel
        ///
        /// The default value is 0x00
        pub single_adc_en, set_single_adc_en: 0;
    }

    impl Mdmcfg1 {
        pub fn dvga_gain(&self) -> DvgaGainValue {
            unsafe { transmute(self.dvga_gain_bits()) }
        }

        pub fn set_dvga_gain(&mut self, value: DvgaGainValue) {
            self.set_dvga_gain_bits(value as u8);
        }
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum DvgaGainValue {
        /// 0 dB DVGA (preferred setting for RX filter bandwidth < 100 kHz)
        Db0 = 0b00,
        /// -18 dB DVGA (preferred setting for RX filter bandwidth >= 100 kHz)
        DbMinus18 = 0b01,
        /// 6 dB DVGA
        Db6 = 0b10,
        /// 9 dB DVGA
        Db9 = 0b11,
    }

    impl const Register for Mdmcfg1 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x11);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Mdmcfg1 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Mdmcfg1 {
        fn default() -> Self {
            Self(0x46)
        }
    }

    impl core::fmt::Debug for Mdmcfg1 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Mdmcfg1 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// General Modem Parameter Configuration Reg. 0
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Mdmcfg0(u8);

        /// For test purposes only, use values from SmartRF Studio.
        pub mdmcfg0_reserved7, set_mdmcfg0_reserved7: 7;

        /// Transparent mode enable
        ///
        /// # Values
        ///
        /// - false: Transparent mode disabled
        /// - true: Transparent mode enabled
        ///
        /// The default value is 0x00
        pub transparent_mode_en, set_transparent_mode_en: 6;

        /// Transparent signal interpolation factor. The sample rate gives the jitter of the samples and the sample rate is given by:<BR/>
        /// Sample Rate = f_xosc*Interpolation Facor/(Decimation Factor*CHAN_BW.BB_CIC_DECFACT) [Hz]<BR/>
        /// The decimation factor is given by CHAN_BW.ADC_CIC_DECFACT while the interpolation factor is given below
        transparent_intfact_bits, set_transparent_intfact_bits: 5, 4;

        /// Transparent data filter and extended data filter enable. Enabling transparent data filter and/or extended data filter might Improve sensitivity. When TRANSPARENT_MODE_EN = 0 this bit should only be set when RX filter bandwidth/symbol rate > 10 and TOC_CFG.TOC_LIMIT = 0. The table below shows the status of the transparent data filter and the extended data filter for all combinations of TRANSPARENT_MODE_EN (MSB) and DATA_FILTER_EN (LSB)
        ///
        /// # Values
        ///
        /// - false: Transparent data filter disabled and extended data filter disabled
        /// - false: Transparent data filter disabled and extended data filter enabled
        /// - false: Transparent data filter disabled and extended data filter disabled
        /// - false: Transparent data filter enabled and extended data filter disabled
        ///
        /// The default value is 0x01
        pub data_filter_en, set_data_filter_en: 3;

        /// Viterbi detection enable. Enabling Viterbi detection improves the sensitivity. The latency from the antenna to the signal is available in the RXFIFO or on the GPIO is increased by 5 bits for 2-ary modulation formats and 10 bits for 4-ary modulation formats. Minimum packet length = 2 bytes when Viterbi Detection and 4-(G)FSK is enabled
        ///
        /// # Values
        ///
        /// - false: Viterbi detection disabled
        /// - true: Viterbi detection enabled
        ///
        /// The default value is 0x01
        pub viterbi_en, set_viterbi_en: 2;

        /// For test purposes only, use values from SmartRF Studio.
        pub mdmcfg0_reserved1, set_mdmcfg0_reserved1: 1;

        /// For test purposes only, use values from SmartRF Studio.
        pub mdmcfg0_reserved0, set_mdmcfg0_reserved0: 0;
    }

    impl Mdmcfg0 {
        pub fn transparent_intfact(&self) -> TransparentIntfactValue {
            unsafe { transmute(self.transparent_intfact_bits()) }
        }

        pub fn set_transparent_intfact(&mut self, value: TransparentIntfactValue) {
            self.set_transparent_intfact_bits(value as u8);
        }
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum TransparentIntfactValue {
        /// 1x transparent signal interpolated one time before output (reset)
        OneTime = 0b00,
        /// 2x transparent signal interpolated two times before output
        TwoTimes = 0b01,
        /// 4x transparent signal interpolated four times before output
        FourTimes = 0b10,
        /// Reserved
        Reserved_11 = 0b11,
    }

    impl const Register for Mdmcfg0 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x12);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Mdmcfg0 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Mdmcfg0 {
        fn default() -> Self {
            Self(0x0d)
        }
    }

    impl core::fmt::Debug for Mdmcfg0 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Mdmcfg0 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Symbol Rate Configuration Exponent and Mantissa [19:16]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct SymbolRate2(u8);

        /// Symbol rate (exponent part)<BR/>
        /// SRATE_E > 0 => Symbol Rate = f_xosc*(2^20+SRATE_M)*2^SRATE_E/2^39 [ksps]<BR/>
        /// SRATE_E = 0 => Symbol Rate = f_xosc*SRATE_M/2^38 [ksps]
        pub srate_e, set_srate_e: 7, 4;

        /// Symbol rate (mantissa part [19:16]). See SRATE_E
        pub srate_m_19_16, set_srate_m_19_16: 3, 0;
    }

    impl const Register for SymbolRate2 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x13);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for SymbolRate2 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for SymbolRate2 {
        fn default() -> Self {
            Self(0x43)
        }
    }

    impl core::fmt::Debug for SymbolRate2 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for SymbolRate2 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Symbol Rate Configuration Mantissa [15:8]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct SymbolRate1(u8);

        /// Symbol rate (mantissa part [15:8]). See SYMBOL_RATE2
        pub srate_m_15_8, set_srate_m_15_8: 7, 0;
    }

    impl const Register for SymbolRate1 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x14);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for SymbolRate1 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for SymbolRate1 {
        fn default() -> Self {
            Self(0xa9)
        }
    }

    impl core::fmt::Debug for SymbolRate1 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for SymbolRate1 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Symbol Rate Configuration Mantissa [7:0]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct SymbolRate0(u8);

        /// Symbol rate (mantissa part [7:0]). See SYMBOL_RATE2
        pub srate_m_7_0, set_srate_m_7_0: 7, 0;
    }

    impl const Register for SymbolRate0 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x15);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for SymbolRate0 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for SymbolRate0 {
        fn default() -> Self {
            Self(0x2a)
        }
    }

    impl core::fmt::Debug for SymbolRate0 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for SymbolRate0 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// AGC Reference Level Configuration
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AgcRef(u8);

        /// AGC reference level. The AGC reference level must be higher than the minimum SNR to the demodulator. The AGC reduces the analog front end gain when the magnitude output from channel filter > AGC reference level. An optimum AGC reference level is given by several conditions, but a rule of thumb is to use the formula:<BR/>
        /// AGC_REFERENCE = 10*log10(RX Filter BW) - 92 - RSSI Offset<BR/>
        /// For Zero-IF configuration, AGC hysteresis > 3 dB, or modem format which needs SNR>15 dB a higher AGC reference value is needed
        /// </br>
        pub agc_reference, set_agc_reference: 7, 0;
    }

    impl const Register for AgcRef {
        const ADDRESS: RegisterAddress = RegisterAddress(0x16);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AgcRef {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AgcRef {
        fn default() -> Self {
            Self(0x36)
        }
    }

    impl core::fmt::Debug for AgcRef {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AgcRef {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Carrier Sense Threshold Configuration
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AgcCsThr(u8);

        /// AGC carrier sense threshold. Two's complement number with 1 dB resolution
        pub agc_cs_threshold, set_agc_cs_threshold: 7, 0;
    }

    impl const Register for AgcCsThr {
        const ADDRESS: RegisterAddress = RegisterAddress(0x17);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AgcCsThr {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AgcCsThr {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for AgcCsThr {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AgcCsThr {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// RSSI Offset Configuration
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AgcGainAdjust(u8);

        /// AGC gain adjustment. This register is used to adjust RSSI[11:0] to the actual carrier input signal level to compensate for interpolation gains (two's complement with 1 dB resolution)
        pub gain_adjustment, set_gain_adjustment: 7, 0;
    }

    impl const Register for AgcGainAdjust {
        const ADDRESS: RegisterAddress = RegisterAddress(0x18);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AgcGainAdjust {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AgcGainAdjust {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for AgcGainAdjust {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AgcGainAdjust {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Automatic Gain Control Configuration Reg. 3
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AgcCfg3(u8);

        /// AGC behavior after sync word detection
        agc_sync_behaviour_bits, set_agc_sync_behaviour_bits: 7, 5;

        /// AGC minimum gain. Limits the AGC minimum gain compared to the preset gain table range. AGC_MIN_GAIN can have a value in the range<BR/>
        /// 0 to 17 when AGC_CFG2.FE_PERFORMANCE_MODE = 0 or 1,<BR/>
        /// 0 to 13 when AGC_CFG2.FE_PERFORMANCE_MODE = 10b and<BR/>
        /// 0 to 7 when AGC_CFG2.FE_PERFORMANCE_MODE = 11b
        pub agc_min_gain, set_agc_min_gain: 4, 0;
    }

    impl AgcCfg3 {
        pub fn agc_sync_behaviour(&self) -> AgcSyncBehaviourValue {
            unsafe { transmute(self.agc_sync_behaviour_bits()) }
        }

        pub fn set_agc_sync_behaviour(&mut self, value: AgcSyncBehaviourValue) {
            self.set_agc_sync_behaviour_bits(value as u8);
        }
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum AgcSyncBehaviourValue {
        /// No AGC gain freeze. Keep computing/updating RSSI
        NoAgcGainFreeze_000 = 0b000,
        /// AGC gain freeze. Keep computing/updating RSSI
        AgcGainFreeze = 0b001,
        /// No AGC gain freeze. Keep computing/updating RSSI (AGC slow mode enabled)
        NoAgcGainFreezeSlowMode_010 = 0b010,
        /// Freeze both AGC gain and RSSI
        FreezeBothAgcGainAndRssi_011 = 0b011,
        /// No AGC gain freeze. Keep computing/updating RSSI
        NoAgcGainFreeze_100 = 0b100,
        /// Freeze both AGC gain and RSSI
        FreezeBothAgcGainAndRssi_101 = 0b101,
        /// No AGC gain freeze. Keep computing/updating RSSI (AGC slow mode enabled)
        NoAgcGainFreezeSlowMode_110 = 0b110,
        /// Freeze both AGC gain and RSSI
        FreezeBothAgcGainAndRssi_111 = 0b111,
    }

    impl const Register for AgcCfg3 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x19);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AgcCfg3 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AgcCfg3 {
        fn default() -> Self {
            Self(0xb1)
        }
    }

    impl core::fmt::Debug for AgcCfg3 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AgcCfg3 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Automatic Gain Control Configuration Reg. 2
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AgcCfg2(u8);

        ///
        /// # Values
        ///
        /// - false: Receiver starts with maximum gain value
        /// - true: Receiver starts from previous gain value
        ///
        /// The default value is 0x00
        pub start_previous_gain_en, set_start_previous_gain_en: 7;

        /// Controls which gain tables to be applied
        fe_performance_mode_bits, set_fe_performance_mode_bits: 6, 5;

        /// AGC maximum gain. Limits the AGC maximum gain compared to the preset gain table range. AGC_MAX_GAIN can have a value in the range<BR/>
        /// 0 to 17 when AGC_CFG2.FE_PERFORMANCE_MODE = 0 or 1,<BR/>
        /// 0 to 13 when AGC_CFG2.FE_PERFORMANCE_MODE = 10b and<BR/>
        /// 0 to 7 when AGC_CFG2.FE_PERFORMANCE_MODE = 11b
        pub agc_max_gain, set_agc_max_gain: 4, 0;
    }

    impl AgcCfg2 {
        pub fn fe_performance_mode(&self) -> FePerformanceModeValue {
            unsafe { transmute(self.fe_performance_mode_bits()) }
        }

        pub fn set_fe_performance_mode(&mut self, value: FePerformanceModeValue) {
            self.set_fe_performance_mode_bits(value as u8);
        }
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum FePerformanceModeValue {
        /// Optimized linearity mode
        OptimizedLinearityMode = 0b00,
        /// Normal operation mode
        NormalOperationMode = 0b01,
        /// Low power mode with reduced gain range
        LowPowerModeWithReducedGainRange = 0b10,
        /// Zero-IF mode
        ZeroIfMode = 0b11,
    }

    impl const Register for AgcCfg2 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x1A);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AgcCfg2 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AgcCfg2 {
        fn default() -> Self {
            Self(0x20)
        }
    }

    impl core::fmt::Debug for AgcCfg2 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AgcCfg2 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Automatic Gain Control Configuration Reg. 1
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AgcCfg1(u8);

        pub agc_cfg1_not_used, _: 7;

        /// AGC has a built in function to signal if there has been a step in the RSSI value. During sync search the difference between the current and the previous RSSI value is compared against the RSSI step (3 or 6 dB), while during packet reception, the difference between the current value and the value at sync found is compared against 10 or 16 dB
        ///
        /// # Values
        ///
        /// - false: RSSI step is 3 dB during sync search / RSSI step is 10 dB during packet reception
        /// - true: RSSI step is 6 dB during sync search / RSSI step is 16 dB during packet reception
        ///
        /// The default value is 0x01
        pub rssi_step_thr, set_rssi_step_thr: 6;

        /// AGC integration window size for each value. Samples refer to the RX filter sampling frequency, which is programmed to be 4 times the desired RX filter BW
        agc_win_size_bits, set_agc_win_size_bits: 5, 3;

        /// Sets the wait time between AGC gain adjustments
        agc_settle_wait_bits, set_agc_settle_wait_bits: 2, 0;
    }

    impl AgcCfg1 {
        pub fn agc_win_size(&self) -> AgcWinSizeValue {
            unsafe { transmute(self.agc_win_size_bits()) }
        }

        pub fn set_agc_win_size(&mut self, value: AgcWinSizeValue) {
            self.set_agc_win_size_bits(value as u8);
        }
        pub fn agc_settle_wait(&self) -> AgcSettleWaitValue {
            unsafe { transmute(self.agc_settle_wait_bits()) }
        }

        pub fn set_agc_settle_wait(&mut self, value: AgcSettleWaitValue) {
            self.set_agc_settle_wait_bits(value as u8);
        }
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum AgcWinSizeValue {
        /// 8 samples
        Samples8 = 0b000,
        /// 16 samples
        Samples16 = 0b001,
        /// 32 samples
        Samples32 = 0b010,
        /// 64 samples
        Samples64 = 0b011,
        /// 128 samples
        Samples128 = 0b100,
        /// 256 samples
        Samples256 = 0b101,
        /// Reserved
        Reserved_110 = 0b110,
        /// Reserved
        Reserved_111 = 0b111,
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum AgcSettleWaitValue {
        /// 24 samples
        Samples24 = 0b000,
        /// 32 samples
        Samples32 = 0b001,
        /// 40 samples
        Samples40 = 0b010,
        /// 48 samples
        Samples48 = 0b011,
        /// 64 samples
        Samples64 = 0b100,
        /// 80 samples
        Samples80 = 0b101,
        /// 96 samples
        Samples96 = 0b110,
        /// 127 samples
        Samples127 = 0b111,
    }

    impl const Register for AgcCfg1 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x1B);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AgcCfg1 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AgcCfg1 {
        fn default() -> Self {
            Self(0x52)
        }
    }

    impl core::fmt::Debug for AgcCfg1 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AgcCfg1 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Automatic Gain Control Configuration Reg. 0
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AgcCfg0(u8);

        /// AGC hysteresis level. The difference between the desired signal level and the actual signal level must be larger than AGC hysteresis level before the AGC changes the front end gain
        agc_hyst_level_bits, set_agc_hyst_level_bits: 7, 6;

        /// AGC slew rate limit. Limits the maximum front end gain adjustment
        agc_slewrate_limit_bits, set_agc_slewrate_limit_bits: 5, 4;

        /// Gives the number of new input samples to the moving average filter (internal RSSI estimates) that are required before the next update of the RSSI value. The RSSI_VALID signal will be asserted from the first RSSI update. RSSI_VALID is available on a GPIO or can be read from the RSSI0 register
        rssi_valid_cnt_bits, set_rssi_valid_cnt_bits: 3, 2;

        /// The OOK/ASK receiver uses a max peak magnitude (logic 1) tracker and low peak magnitude (logic 0) tracker to estimate ASK_THRESHOLD (decision level) as the average of the max and min value. The max peak magnitude value is also used by the AGC to set the gain. AGC_ASK_DECAY controls the max peak magnitude decay steps in OOK/ASK mode and defines the number of samples required for the max peak level to be reduced to 10% when receiving logic 0 after receiving a logic 1.
        /// <BR/> <BR/>
        /// Sample Rate = (f_xosc*Interpolation Factor)/(Decimation Factor*CHAN_BW.BB_CIC_DECFACT)[Hz]
        /// <BR/> <BR/>
        /// The decimation factor is given by CHAN_BW.ADC_CIC_DECFACT and the interpolation factor is given by SYNC_CFG0.RX_CONFIG_LIMITATION as follows:</br>
        agc_ask_decay_bits, set_agc_ask_decay_bits: 1, 0;
    }

    impl AgcCfg0 {
        pub fn agc_hyst_level(&self) -> AgcHystLevelValue {
            unsafe { transmute(self.agc_hyst_level_bits()) }
        }

        pub fn set_agc_hyst_level(&mut self, value: AgcHystLevelValue) {
            self.set_agc_hyst_level_bits(value as u8);
        }
        pub fn agc_slewrate_limit(&self) -> AgcSlewrateLimitValue {
            unsafe { transmute(self.agc_slewrate_limit_bits()) }
        }

        pub fn set_agc_slewrate_limit(&mut self, value: AgcSlewrateLimitValue) {
            self.set_agc_slewrate_limit_bits(value as u8);
        }
        pub fn rssi_valid_cnt(&self) -> RssiValidCntValue {
            unsafe { transmute(self.rssi_valid_cnt_bits()) }
        }

        pub fn set_rssi_valid_cnt(&mut self, value: RssiValidCntValue) {
            self.set_rssi_valid_cnt_bits(value as u8);
        }
        pub fn agc_ask_decay(&self) -> AgcAskDecayValue {
            unsafe { transmute(self.agc_ask_decay_bits()) }
        }

        pub fn set_agc_ask_decay(&mut self, value: AgcAskDecayValue) {
            self.set_agc_ask_decay_bits(value as u8);
        }
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum AgcHystLevelValue {
        /// 2 dB
        Db2 = 0b00,
        /// 4 dB
        Db4 = 0b01,
        /// 7 dB
        Db7 = 0b10,
        /// 10 dB
        Db10 = 0b11,
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum AgcSlewrateLimitValue {
        /// 60 dB
        Db60 = 0b00,
        /// 30 dB
        Db30 = 0b01,
        /// 18 dB
        Db18 = 0b10,
        /// 9 dB
        Db9 = 0b11,
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum RssiValidCntValue {
        /// 1
        Count1 = 0b00,
        /// 2
        Count2 = 0b01,
        /// 5
        Count5 = 0b10,
        /// 9
        Count9 = 0b11,
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum AgcAskDecayValue {
        /// 1200 samples
        Samples1200 = 0b00,
        /// 2400 samples
        Samples2400 = 0b01,
        /// 4700 samples
        Samples4700 = 0b10,
        /// 9500 samples
        Samples9500 = 0b11,
    }

    impl const Register for AgcCfg0 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x1C);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AgcCfg0 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AgcCfg0 {
        fn default() -> Self {
            Self(0xc3)
        }
    }

    impl core::fmt::Debug for AgcCfg0 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AgcCfg0 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// FIFO Configuration
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct FifoCfg(u8);

        /// Automatically flushes the last packet received in the RX FIFO if a CRC error occurred. If this bit has been turned off and should be turned on again, an SFRX strobe must first be issued
        pub crc_autoflush, set_crc_autoflush: 7;

        /// Threshold value for the RX and TX FIFO. The threshold value is coded in opposite directions for the two FIFOs to give equal margin to the overflow and underflow conditions when the threshold is reached. I.e.; FIFO_THR = 0 means that there are 127 bytes in the TX FIFO and 1 byte in the RX FIFO, while FIFO_THR = 127 means that there are 0 bytes in the TX FIFO and 128 bytes in the RX FIFO when the thresholds are reached
        pub fifo_thr, set_fifo_thr: 6, 0;
    }

    impl const Register for FifoCfg {
        const ADDRESS: RegisterAddress = RegisterAddress(0x1D);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for FifoCfg {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for FifoCfg {
        fn default() -> Self {
            Self(0x80)
        }
    }

    impl core::fmt::Debug for FifoCfg {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for FifoCfg {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Device Address Configuration
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct DevAddr(u8);

        /// Address used for packet filtering in RX
        pub device_addr, set_device_addr: 7, 0;
    }

    impl const Register for DevAddr {
        const ADDRESS: RegisterAddress = RegisterAddress(0x1E);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for DevAddr {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for DevAddr {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for DevAddr {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for DevAddr {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Frequency Synthesizer Calibration and Settling Configuration
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct SettlingCfg(u8);

        pub settling_cfg_not_used, _: 7, 5;

        /// Auto calibration is performed:
        fs_autocal_bits, set_fs_autocal_bits: 4, 3;

        /// Sets the time for the frequency synthesizer to settle to lock state. The table shows settling after calibration and settling when switching between TX and RX. Use values from SmartRF Studio
        ///
        /// # Values
        ///
        /// - 00b: 50 / 20 us
        /// - 01b: 75 / 30 us
        /// - 10b: 100 / 40 us
        /// - 11b: 150 / 60 us
        ///
        /// The default value is 0x01
        pub lock_time, set_lock_time: 2, 1;

        /// Frequency synthesizer regulator settling time. Use values from SmartRF Studio
        ///
        /// # Values
        ///
        /// - false: 30 us
        /// - true: 60 us
        ///
        /// The default value is 0x01
        pub fsreg_time, set_fsreg_time: 0;
    }

    impl SettlingCfg {
        pub fn fs_autocal(&self) -> FsAutocalValue {
            unsafe { transmute(self.fs_autocal_bits()) }
        }

        pub fn set_fs_autocal(&mut self, value: FsAutocalValue) {
            self.set_fs_autocal_bits(value as u8);
        }
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum FsAutocalValue {
        /// Never (manually calibrate using SCAL strobe)
        Never = 0b00,
        /// When going from IDLE to RX or TX (or FSTXON)
        WhenGoingFromIdleToRxOrTx = 0b01,
        /// When going from RX or TX back to IDLE automatically
        WhenGoingFromRxOrTxBackToIdleAutomatically = 0b10,
        /// Every 4th time when going from RX or TX to IDLE automatically
        Every4thTimeWhenGoingFromRxOrTxToIdleAutomatically = 0b11,
    }

    impl const Register for SettlingCfg {
        const ADDRESS: RegisterAddress = RegisterAddress(0x1F);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for SettlingCfg {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for SettlingCfg {
        fn default() -> Self {
            Self(0x0b)
        }
    }

    impl core::fmt::Debug for SettlingCfg {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for SettlingCfg {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Frequency Synthesizer Configuration
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct FsCfg(u8);

        pub fs_cfg_not_used, _: 7, 5;

        /// Out of lock detector enable
        ///
        /// # Values
        ///
        /// - false: Out of lock detector disabled
        /// - true: Out of lock detector enabled
        ///
        /// The default value is 0x00
        pub fs_lock_en, set_fs_lock_en: 4;

        /// Band select setting for LO divider
        fsd_bandselect_bits, set_fsd_bandselect_bits: 3, 0;
    }

    impl FsCfg {
        pub fn fsd_bandselect(&self) -> FsdBandselectValue {
            unsafe { transmute(self.fsd_bandselect_bits()) }
        }

        pub fn set_fsd_bandselect(&mut self, value: FsdBandselectValue) {
            self.set_fsd_bandselect_bits(value as u8);
        }
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum FsdBandselectValue {
        /// Not in use
        NotInUse_0000 = 0b0000,
        /// Not in use
        NotInUse_0001 = 0b0001,
        /// 820.0 - 960.0 MHz band (LO divider = 4)
        Band820 = 0b0010,
        /// Not in use
        NotInUse_0011 = 0b0011,
        /// 410.0 - 480.0 MHz band (LO divider = 8)
        Band410 = 0b0100,
        /// Not in use
        NotInUse_0101 = 0b0101,
        /// 273.3 - 320.0 MHz band (LO divider = 12)
        Band273 = 0b0110,
        /// Not in use
        NotInUse_0111 = 0b0111,
        /// 205.0 - 240.0 MHz band (LO divider = 16)
        Band205 = 0b1000,
        /// Not in use
        NotInUse_1001 = 0b1001,
        /// 164.0 - 192.0 MHz band (LO divider = 20)
        Band164 = 0b1010,
        /// 136.7 - 160.0 MHz band (LO divider = 24)
        Band136 = 0b1011,
        /// Not in use
        NotInUse_1100 = 0b1100,
        /// Not in use
        NotInUse_1101 = 0b1101,
        /// Not in use
        NotInUse_1110 = 0b1110,
        /// Not in use
        NotInUse_1111 = 0b1111,
    }

    impl const Register for FsCfg {
        const ADDRESS: RegisterAddress = RegisterAddress(0x20);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for FsCfg {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for FsCfg {
        fn default() -> Self {
            Self(0x02)
        }
    }

    impl core::fmt::Debug for FsCfg {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for FsCfg {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// eWOR Configuration Reg. 1
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct WorCfg1(u8);

        /// eWOR timer resolution. Controls the t_Event0 and RX timeout resolution<BR/>
        /// t_EVENT0 =  2^(5*WOR_RES)*EVENT0/f_rcosc [s] and<BR/>
        /// RX Timeout = MAX[1,FLOOR[EVENT0/2^(RFEND_CFG1.RX_TIME+3)]]*2^(4*WOR_RES)*1250/f_xosc [s]
        wor_res_bits, set_wor_res_bits: 7, 6;

        /// eWOR mode
        ///
        /// # Values
        ///
        /// - 000b: Feedback mode
        /// - 001b: Normal mode
        /// - 010b: Legacy mode
        /// - 011b: Event1 mask mode
        /// - 100b: Event0 mask mode
        /// - 111b: Reserved
        ///
        /// The default value is 0x01
        pub wor_mode, set_wor_mode: 5, 3;

        /// Event 1 timeout<BR/>
        /// t_EVENT1 = WOR_EVENT1/f_rcosc [s]
        /// </br>
        pub event1, set_event1: 2, 0;
    }

    impl WorCfg1 {
        pub fn wor_res(&self) -> WorResValue {
            unsafe { transmute(self.wor_res_bits()) }
        }

        pub fn set_wor_res(&mut self, value: WorResValue) {
            self.set_wor_res_bits(value as u8);
        }
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum WorResValue {
        /// High resolution
        HighResolution = 0b00,
        /// Medium high resolution
        MediumHighResolution = 0b01,
        /// Medium low resolution
        MediumLowResolution = 0b10,
        /// Low resolution
        LowResolution = 0b11,
    }

    impl const Register for WorCfg1 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x21);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for WorCfg1 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for WorCfg1 {
        fn default() -> Self {
            Self(0x08)
        }
    }

    impl core::fmt::Debug for WorCfg1 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for WorCfg1 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// eWOR Configuration Reg. 0
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct WorCfg0(u8);

        /// RX duty cycle mode configuration. eWOR mode and RXDCM cannot be enabled at the same time. Both modes can be used in RX Sniff Mode implementation
        rx_duty_cycle_mode_bits, _: 7, 6;

        /// Clock division enable. Enables clock division in SLEEP mode
        /// Setting DIV_256HZ_EN = 1 will lower the current consumption in SLEEP mode. Note that when this bit is set the radio should not be woken from SLEEP by pulling CSn low
        ///
        /// # Values
        ///
        /// - false: Clock division disabled
        /// - true: Clock division enabled
        ///
        /// The default value is 0x01
        pub div_256hz_en, set_div_256hz_en: 5;

        /// Event 2 timeout<BR/>
        /// t_EVENT2 = 2^WOR_EVENT2/f_rcosc [s]
        pub event2_cfg, set_event2_cfg: 4, 3;

        /// RCOSC calibration mode. Configures when the RCOSC calibration sequence is performed. If calibration is enabled, WOR_CFG0.RC_PD must be 0
        rc_mode_bits, set_rc_mode_bits: 2, 1;

        /// RCOSC power down signal
        ///
        /// # Values
        ///
        /// - false: RCOSC is running
        /// - true: RCOSC is in power down
        ///
        /// The default value is 0x01
        pub rc_pd, set_rc_pd: 0;
    }

    impl WorCfg0 {
        pub fn rx_duty_cycle_mode(&self) -> RxDutyCycleModeValue {
            unsafe { transmute(self.rx_duty_cycle_mode_bits()) }
        }
        pub fn rc_mode(&self) -> RcModeValue {
            unsafe { transmute(self.rc_mode_bits()) }
        }

        pub fn set_rc_mode(&mut self, value: RcModeValue) {
            self.set_rc_mode_bits(value as u8);
        }
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum RxDutyCycleModeValue {
        /// RXDCM disabled
        RxdcmDisabled = 0b00,
        /// RXDCM 0
        Rxdcm0 = 0b01,
        /// RXDCM 1
        Rxdcm1 = 0b10,
        /// RXDCM 2
        Rxdcm2 = 0b11,
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum RcModeValue {
        /// RCOSC calibration disabled
        RcoscCalibrationDisabled_00 = 0b00,
        /// RCOSC calibration disabled
        RcoscCalibrationDisabled_01 = 0b01,
        /// RCOSC calibration enabled
        RcoscCalibrationEnabled = 0b10,
        /// RCOSC calibration is enabled on every 4th time the device is powered up and goes from IDLE to RX. This setting should only be used together with eWOR
        RcoscCalibrationIsEnabledOnEvery4thTimeTheDeviceIsPoweredUpAndGoesFromIdleToRx = 0b11,
    }

    impl const Register for WorCfg0 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x22);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for WorCfg0 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for WorCfg0 {
        fn default() -> Self {
            Self(0x21)
        }
    }

    impl core::fmt::Debug for WorCfg0 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for WorCfg0 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Event 0 Configuration MSB
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct WorEvent0Msb(u8);

        /// Event 0 timeout (MSB)<BR/>
        /// t_EVENT0 = 2^(5*WOR_CFG1.WOR_RES)*EVENT0/f_rcosc [s]
        pub event0_15_8, set_event0_15_8: 7, 0;
    }

    impl const Register for WorEvent0Msb {
        const ADDRESS: RegisterAddress = RegisterAddress(0x23);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for WorEvent0Msb {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for WorEvent0Msb {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for WorEvent0Msb {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for WorEvent0Msb {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Event 0 Configuration LSB
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct WorEvent0Lsb(u8);

        /// Event 0 timeout (LSB). See WOR_EVENT0_MSB
        pub event0_7_0, set_event0_7_0: 7, 0;
    }

    impl const Register for WorEvent0Lsb {
        const ADDRESS: RegisterAddress = RegisterAddress(0x24);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for WorEvent0Lsb {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for WorEvent0Lsb {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for WorEvent0Lsb {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for WorEvent0Lsb {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// RX Duty Cycle Mode Configuration
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct RxdcmTime(u8);

        /// Configures the time spent in RXDCM state</br>
        /// RX_DUTY_CYCLE_TIME = 0:</br>
        /// t_RXDCM = 2^WOR_CFG1.WOR_RES[us]</br>
        /// RX_DUTY_CYCLE_TIME != 0:</br>
        /// t_RXDCM = RX_DUTY_CYCLE_TIME*2^WOR_CFG1.WOR_RES[us]
        pub rx_duty_cycle_time, set_rx_duty_cycle_time: 7, 0;
    }

    impl const Register for RxdcmTime {
        const ADDRESS: RegisterAddress = RegisterAddress(0x25);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for RxdcmTime {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for RxdcmTime {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for RxdcmTime {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for RxdcmTime {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Packet Configuration Reg. 2
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct PktCfg2(u8);

        pub pkt_cfg2_not_used, _: 7;

        /// TX/RX data byte swap enable. In RX, all bits in the received data byte are swapped before written to the RX FIFO. In TX, all bits in the TX FIFO data byte are swapped before being transmitted
        ///
        /// # Values
        ///
        /// - false: Data byte swap disabled
        /// - true: Data byte swap enabled
        ///
        /// The default value is 0x00
        pub byte_swap_en, set_byte_swap_en: 6;

        /// Select between standard packet mode or 802.15.4g packet mode
        ///
        /// # Values
        ///
        /// - false: Standard packet mode enabled
        /// - true: 802.15.4g packet mode enabled (will override other packet engine configuration settings)
        ///
        /// The default value is 0x00
        pub fg_mode_en, set_fg_mode_en: 5;

        /// CCA mode. Selects the definition of a clear channel (when to assert the CCA signal)
        cca_mode_bits, set_cca_mode_bits: 4, 2;

        /// Packet format configuration
        pkt_format_bits, set_pkt_format_bits: 1, 0;
    }

    impl PktCfg2 {
        pub fn cca_mode(&self) -> CcaModeValue {
            unsafe { transmute(self.cca_mode_bits()) }
        }

        pub fn set_cca_mode(&mut self, value: CcaModeValue) {
            self.set_cca_mode_bits(value as u8);
        }
        pub fn pkt_format(&self) -> PktFormatValue {
            unsafe { transmute(self.pkt_format_bits()) }
        }

        pub fn set_pkt_format(&mut self, value: PktFormatValue) {
            self.set_pkt_format_bits(value as u8);
        }
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum CcaModeValue {
        /// Always give a clear channel indication
        AlwaysGiveAClearChannelIndication = 0b000,
        /// Indicates clear channel when RSSI is below threshold
        IndicatesClearChannelWhenRssiIsBelowThreshold = 0b001,
        /// Indicates clear channel unless currently receiving a packet
        IndicatesClearChannelUnlessCurrentlyReceivingAPacket = 0b010,
        /// Indicates clear channel when RSSI is below threshold and currently not receiving a packet
        IndicatesClearChannelWhenRssiIsBelowThresholdAndCurrentlyNotReceivingAPacket = 0b011,
        /// Indicates clear channel when RSSI is below threshold and ETSI LBT requirements are met
        IndicatesClearChannelWhenRssiIsBelowThresholdAndEtsiLbtRequirementsAreMet = 0b100,
        /// Reserved
        Reserved_101 = 0b101,
        /// Reserved
        Reserved_110 = 0b110,
        /// Reserved
        Reserved_111 = 0b111,
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum PktFormatValue {
        /// Normal mode / FIFO mode (MDMCFG1.FIFO_EN must be set to 1 and MDMCFG0.TRANSPARENT_MODE_EN must be set to 0)
        NormalModeFifoMode = 0b00,
        /// Synchronous serial mode (MDMCFG1.FIFO_EN must be set to 0 and MDMCFG0.TRANSPARENT_MODE_EN must be set to 0). This mode is only supported for 2ary modulations formats in TX. In RX, both 2'ary and 4ary modulation formats are supported
        SynchronousSerialMode = 0b01,
        /// Random mode. Send random data using PN9 generator (Set TXLAST != TXFIRST before strobing STX)
        RandomMode = 0b10,
        /// Transparent serial mode (MDMCFG1.FIFO_EN must be set to 0 and MDMCFG0.TRANSPARENT_MODE_EN must be set to 1). This mode is only supported for 2ary modulations formats
        TransparentSerialMode = 0b11,
    }

    impl const Register for PktCfg2 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x26);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for PktCfg2 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for PktCfg2 {
        fn default() -> Self {
            Self(0x04)
        }
    }

    impl core::fmt::Debug for PktCfg2 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for PktCfg2 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Packet Configuration Reg. 1
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct PktCfg1(u8);

        /// Forward error correction enable
        ///
        /// # Values
        ///
        /// - false: FEC disabled
        /// - true: FEC enabled
        ///
        /// The default value is 0x00
        pub fec_en, set_fec_en: 7;

        /// Whitening enable
        ///
        /// # Values
        ///
        /// - false: Data whitening disabled
        /// - true: Data whitening enabled
        ///
        /// The default value is 0x00
        pub white_data, set_white_data: 6;

        /// PN9 sequence swap enable Determines if the PN9 sequence is swapped prior to whitening/de-whitening. This settings is only used when WHITE_DATA = 1 and PKT_CFG2.FG_MODE_EN = 0
        ///
        /// # Values
        ///
        /// - false: PN9 sequence swap disabled
        /// - true: PN9 sequence swap enabled
        ///
        /// The default value is 0x00
        pub pn9_swap_en, set_pn9_swap_en: 5;

        /// Address check configuration. Controls how address check is performed in RX mode
        addr_check_cfg_bits, set_addr_check_cfg_bits: 4, 3;

        /// CRC configuration
        crc_cfg_bits, set_crc_cfg_bits: 2, 1;

        /// Append status bytes to RX FIFO. The status bytes contain info about CRC, RSSI, and LQI. When PKT_CFG1.CRC_CFG = 0, the CRC_OK field in the status byte will be 0
        ///
        /// # Values
        ///
        /// - false: Status byte not appended
        /// - true: Status byte appended
        ///
        /// The default value is 0x01
        pub append_status, set_append_status: 0;
    }

    impl PktCfg1 {
        pub fn addr_check_cfg(&self) -> AddrCheckCfgValue {
            unsafe { transmute(self.addr_check_cfg_bits()) }
        }

        pub fn set_addr_check_cfg(&mut self, value: AddrCheckCfgValue) {
            self.set_addr_check_cfg_bits(value as u8);
        }
        pub fn crc_cfg(&self) -> CrcCfgValue {
            unsafe { transmute(self.crc_cfg_bits()) }
        }

        pub fn set_crc_cfg(&mut self, value: CrcCfgValue) {
            self.set_crc_cfg_bits(value as u8);
        }
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum AddrCheckCfgValue {
        /// No address check
        NoAddressCheck = 0b00,
        /// Address check, no broadcast
        AddressCheckNoBroadcast = 0b01,
        /// Address check, 0x00 broadcast
        AddressCheck0x00Broadcast = 0b10,
        /// Address check, 0x00 and 0xFF broadcast
        AddressCheck0x00And0xffBroadcast = 0b11,
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum CrcCfgValue {
        /// CRC disabled for TX and RX
        CrcDisabledForTxAndRx = 0b00,
        /// CRC calculation in TX mode and CRC check in RX mode enabled. CRC16(X16+X15+X2+1). Initialized to 0xFFFF
        CrcEnabledPoly8005InitFFFF = 0b01,
        /// CRC calculation in TX mode and CRC check in RX mode enabled. CRC16(X16+X12+X5+1). Initialized to 0x0000
        CrcEnabledPoly1021Init0000 = 0b10,
        /// CRC calculation in TX mode and CRC check in RX mode enabled. 1's complement of CRC16(X16+X12+X5+1). Initialized to 0x1D0F
        CrcEnabledPoly1021InvInit1D0F = 0b11,
    }

    impl const Register for PktCfg1 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x27);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for PktCfg1 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for PktCfg1 {
        fn default() -> Self {
            Self(0x03)
        }
    }

    impl core::fmt::Debug for PktCfg1 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for PktCfg1 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Packet Configuration Reg. 0
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct PktCfg0(u8);

        /// For test purposes only, use values from SmartRF Studio.
        pub pkt_cfg0_reserved7, set_pkt_cfg0_reserved7: 7;

        /// Packet length configuration
        length_config_bits, set_length_config_bits: 6, 5;

        /// In fixed packet length mode this field (when not zero) indicates the number of bits to send/receive after PKT_LEN number of bytes are sent/received. CRC is not supported when PKT_LEN_BIT != 0
        pub pkt_bit_len, set_pkt_bit_len: 4, 2;

        /// UART mode enable. When enabled, the packet engine will insert/remove a start and stop bit to/from the transmitted/received bytes
        ///
        /// # Values
        ///
        /// - false: UART mode disabled
        /// - true: UART mode enabled
        ///
        /// The default value is 0x00
        pub uart_mode_en, set_uart_mode_en: 1;

        /// Swap start and stop bits values
        ///
        /// # Values
        ///
        /// - false: Swap disabled. Start/stop bits values are '1'/'0'
        /// - true: Swap enabled. Start/stop bits values are '0'/'1'
        ///
        /// The default value is 0x00
        pub uart_swap_en, set_uart_swap_en: 0;
    }

    impl PktCfg0 {
        pub fn length_config(&self) -> LengthConfigValue {
            unsafe { transmute(self.length_config_bits()) }
        }

        pub fn set_length_config(&mut self, value: LengthConfigValue) {
            self.set_length_config_bits(value as u8);
        }
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum LengthConfigValue {
        /// Fixed packet length mode. Packet Length configured through the PKT_LEN register
        FixedPacketLengthMode = 0b00,
        /// Variable packet length mode. Packet length configured by the first byte received after sync word
        VariablePacketLengthMode = 0b01,
        /// Infinite packet length mode
        InfinitePacketLengthMode = 0b10,
        /// Variable packet length mode. Length configured by the 5 LSB of the first byte received after sync word
        VariablePacketLengthMode5Bits = 0b11,
    }

    impl const Register for PktCfg0 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x28);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for PktCfg0 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for PktCfg0 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for PktCfg0 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for PktCfg0 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// RFEND Configuration Reg. 1
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct RfendCfg1(u8);

        pub rfend_cfg1_not_used, _: 7, 6;

        /// RXOFF mode. Determines the state the radio will enter after receiving a good packet
        rxoff_mode_bits, set_rxoff_mode_bits: 5, 4;

        /// RX timeout for sync word search in RX<BR/>
        /// RX Timeout = MAX[1,FLOOR[EVENT0/2^(RX_TIME+3)]]*2^(4*WOR_CFG1.WOR_RES)*1250/f_xosc [s]<BR/>
        /// The RX timeout is disabled when RX_TIME = 111b. EVENT0 is found in the WOR_EVENT0_MSB and WOR_EVENT0_LSB registers
        pub rx_time, set_rx_time: 3, 1;

        /// RX timeout qualifier
        ///
        /// # Values
        ///
        /// - false: Continue RX mode on RX timeout if sync word is found
        /// - true: Continue RX mode on RX timeout if sync word has been found, or if PQT is reached or CS is asserted
        ///
        /// The default value is 0x01
        pub rx_time_qual, set_rx_time_qual: 0;
    }

    impl RfendCfg1 {
        pub fn rxoff_mode(&self) -> RxoffModeValue {
            unsafe { transmute(self.rxoff_mode_bits()) }
        }

        pub fn set_rxoff_mode(&mut self, value: RxoffModeValue) {
            self.set_rxoff_mode_bits(value as u8);
        }
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum RxoffModeValue {
        /// IDLE
        Idle = 0b00,
        /// FSTXON
        Fstxon = 0b01,
        /// TX
        Tx = 0b10,
        /// RX
        Rx = 0b11,
    }

    impl const Register for RfendCfg1 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x29);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for RfendCfg1 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for RfendCfg1 {
        fn default() -> Self {
            Self(0x0f)
        }
    }

    impl core::fmt::Debug for RfendCfg1 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for RfendCfg1 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// RFEND Configuration Reg. 0
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct RfendCfg0(u8);

        pub rfend_cfg0_not_used, _: 7;

        /// Enable additional wake-up pulses on the end of calibration. To be used together with the MCU_WAKEUP signal (MARC_STATUS_OUT will be 0)
        ///
        /// # Values
        ///
        /// - false: Disable additional wake-up pulse
        /// - true: Enable additional wake-up pulse
        ///
        /// The default value is 0x00
        pub cal_end_wake_up_en, set_cal_end_wake_up_en: 6;

        /// TXOFF mode. Determines the state the radio will enter after transmitting a packet
        txoff_mode_bits, set_txoff_mode_bits: 5, 4;

        /// Terminate on bad packet enable
        ///
        /// # Values
        ///
        /// - false: Terminate on bad packet disabled. When a bad packet is received (address, length, or CRC error) the radio stays in RX regardless of the RFEND_CFG1.RXOFF_MODE
        /// - true: Terminate on bad packet enabled. RFEND_CFG1.RXOFF_MODE is ignored and the radio enters IDLE mode (or SLEEP mode if eWOR is used) when a bad packet has been received
        ///
        /// The default value is 0x00
        pub term_on_bad_packet_en, set_term_on_bad_packet_en: 3;

        /// Direct RX termination and antenna diversity configuration
        ant_div_rx_term_cfg_bits, set_ant_div_rx_term_cfg_bits: 2, 0;
    }

    impl RfendCfg0 {
        pub fn txoff_mode(&self) -> TxoffModeValue {
            unsafe { transmute(self.txoff_mode_bits()) }
        }

        pub fn set_txoff_mode(&mut self, value: TxoffModeValue) {
            self.set_txoff_mode_bits(value as u8);
        }
        pub fn ant_div_rx_term_cfg(&self) -> AntDivRxTermCfgValue {
            unsafe { transmute(self.ant_div_rx_term_cfg_bits()) }
        }

        pub fn set_ant_div_rx_term_cfg(&mut self, value: AntDivRxTermCfgValue) {
            self.set_ant_div_rx_term_cfg_bits(value as u8);
        }
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum TxoffModeValue {
        /// IDLE
        Idle = 0b00,
        /// FSTXON
        Fstxon = 0b01,
        /// TX
        Tx = 0b10,
        /// RX
        Rx = 0b11,
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum AntDivRxTermCfgValue {
        /// Antenna diversity and termination based on CS/PQT are disabled
        AntennaDiversityAndTerminationBasedOnCsPqtAreDisabled = 0b000,
        /// RX termination based on CS is enabled (Antenna diversity OFF)
        RxTerminationBasedOnCsIsEnabled = 0b001,
        /// Single-switch antenna diversity on CS enabled. One or both antenna is CS evaluated once and RX will terminate if CS failed on both antennas
        SingleSwitchAntennaDiversityOnCsEnabled = 0b010,
        /// Continuous-switch antenna diversity on CS enabled. Antennas are switched until CS is asserted or RX timeout occurs (if RX timeout is enabled)
        ContinuousSwitchAntennaDiversityOnCsEnabled = 0b011,
        /// RX termination based on PQT is enabled (Antenna diversity OFF). <BR> MDMCFG1.CARRIER_SENSE_GATE must be 0 when this feature is used.
        RxTerminationBasedOnPqtIsEnabled = 0b100,
        /// Single-switch antenna diversity on PQT enabled. One or both antennas are PQT evaluated once and RX will terminate if PQT is not reached on any of the antennas. <BR> MDMCFG1.CARRIER_SENSE_GATE must be 0 when this feature is used.
        SingleSwitchAntennaDiversityOnPqtEnabled = 0b101,
        /// Continuous-switch antenna diversity on PQT enabled. Antennas are switched until PQT is reached or RX timeout occurs (if RX timeout is enabled). <BR> MDMCFG1.CARRIER_SENSE_GATE must be 0 when this feature is used.
        ContinuousSwitchAntennaDiversityOnPqtEnabled = 0b110,
        /// Reserved
        Reserved_111 = 0b111,
    }

    impl const Register for RfendCfg0 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2A);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for RfendCfg0 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for RfendCfg0 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for RfendCfg0 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for RfendCfg0 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Power Amplifier Configuration Reg. 1
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct PaCfg1(u8);

        pub pa_cfg2_not_used, _: 7;

        /// PA ramping and ASK/OOK shaping enable
        ///
        /// # Values
        ///
        /// - false: PA ramping and ASK/OOK shaping disabled
        /// - true: PA ramping and ASK/OOK shaping enabled
        ///
        /// The default value is 0x01
        pub pa_ramp_shape_en, set_pa_ramp_shape_en: 6;

        /// PA power ramp target level<BR/>
        /// Output Power = (PA_POWER_RAMP+1)/2-18 [dBm]<BR/>
        /// PA_POWER_RAMP >= 0x03 for the equation to be valid. {0x00, 0x01, 0x02} are special power levels
        pub pa_power_ramp, set_pa_power_ramp: 5, 0;
    }

    impl const Register for PaCfg1 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2B);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for PaCfg1 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for PaCfg1 {
        fn default() -> Self {
            Self(0x7f)
        }
    }

    impl core::fmt::Debug for PaCfg1 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for PaCfg1 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Power Amplifier Configuration Reg. 0
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct PaCfg0(u8);

        /// First intermediate power level. The first intermediate power level can be programmed within the power level range 0 - 7/16 in steps of 1/16
        pub first_ipl, set_first_ipl: 7, 5;

        /// Second intermediate power level. The second intermediate power level can be programmed within the power level range 8/16 - 15/16 in steps of 1/16
        pub second_ipl, set_second_ipl: 4, 2;

        /// PA ramp time and ASK/OOK shape length. Note that only certain values of PA_CFG0.UPSAMPLER_P complies with the different ASK/OOK shape lengths
        ///
        /// # Values
        ///
        /// - 00b: 3/8 symbol ramp time and 1/32 symbol ASK/OOK shape length (legal UPSAMPLER_P values: 100b, 101b, and 110b)
        /// - 01b: 3/2 symbol ramp time and 1/16 symbol ASK/OOK shape length (legal UPSAMPLER_P values: 011b, 100b, 101b, and 110b)
        /// - 10b: 3 symbol ramp time and 1/8 symbol ASK/OOK shape length (legal UPSAMPLER_P values: 010b, 011b, 100b, 101b, and 110b)
        /// - 11b: 6 symbol ramp time and 1/4 symbol ASK/OOK shape length (legal UPSAMPLER_P values: 010b , 010b, 011b, 100b, 101b, and 110b)
        ///
        /// The default value is 0x02
        pub ramp_shape, set_ramp_shape: 1, 0;
    }

    impl const Register for PaCfg0 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2C);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for PaCfg0 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for PaCfg0 {
        fn default() -> Self {
            Self(0x56)
        }
    }

    impl core::fmt::Debug for PaCfg0 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for PaCfg0 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// ASK Configuration
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AskCfg(u8);

        /// Controls the bandwidth of the data filter in ASK/OOK mode. The -3 dB cut-off frequency (fCut-Off) is given below:</br>
        /// RX_CONFIG_LIMITATION = 0:<BR/>
        /// f-Cut-Off = 4*ASK BW Scale Factor*Rx Filter BW [Hz]<BR/>
        /// RX_CONFIG_LIMITATION = 1:<BR/>
        /// f-Cut-Off = 8*ASK BW Scale Factor*Rx Filter BW [Hz]<BR/>
        /// RX_CONFIG_LIMITATION is found in SYNC_CFG0. A rule of thumb is to set f_Cut-Off >= 5*symbol rate
        agc_ask_bw_bits, set_agc_ask_bw_bits: 7, 6;

        /// ASK/OOK depth<BR/>
        /// A_Max = (PA_CFG1.PA_POWER_RAMP+1)/2-18 [dBm]<BR/>
        /// A_Min = (PA_CFG1.PA_POWER_RAMP+1-ASK_DEPTH)/2-18 [dBm]<BR/>
        /// Minimum PA power level is -16 dBm. PA_POWER_RAMP - ASK_DEPTH = 0x00 is OOK off state (< -50 dBm)
        pub ask_depth, set_ask_depth: 5, 0;
    }

    impl AskCfg {
        pub fn agc_ask_bw(&self) -> AgcAskBwValue {
            unsafe { transmute(self.agc_ask_bw_bits()) }
        }

        pub fn set_agc_ask_bw(&mut self, value: AgcAskBwValue) {
            self.set_agc_ask_bw_bits(value as u8);
        }
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum AgcAskBwValue {
        /// ASK BW scale factor = 0.28
        AskBwScaleFactorEqualPoint28 = 0b00,
        /// ASK BW scale factor = 0.18
        AskBwScaleFactorEqualPoint18 = 0b01,
        /// ASK BW scale factor = 0.15
        AskBwScaleFactorEqualPoint15 = 0b10,
        /// ASK BW scale factor = 0.14
        AskBwScaleFactorEqualPoint14 = 0b11,
    }

    impl const Register for AskCfg {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2D);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AskCfg {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AskCfg {
        fn default() -> Self {
            Self(0x0f)
        }
    }

    impl core::fmt::Debug for AskCfg {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AskCfg {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Packet Length Configuration
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct PktLen(u8);

        /// In fixed length mode this field indicates the packet length, and a value of 0 indicates the length to be 256 bytes. In variable length packet mode, this value indicates the maximum allowed length packets
        pub packet_length, set_packet_length: 7, 0;
    }

    impl const Register for PktLen {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2E);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for PktLen {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for PktLen {
        fn default() -> Self {
            Self(0x03)
        }
    }

    impl core::fmt::Debug for PktLen {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for PktLen {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }
}

pub mod ext {
    use super::*;
    bitfield! {
        /// IF Mix Configuration
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct IfMixCfg(u8);

        pub if_mix_cfg_not_used, _: 7, 5;

        /// Intermediate frequency configuration. The decimation factor is given by CHAN_BW.ADC_CIC_DECFACT
        ///
        /// # Values
        ///
        /// - 000b: Zero-IF
        /// - 001b: f_IF = -f_xosc/(Decimation Factor*4)[kHz]
        /// - 010b: f_IF = -f_xosc/(Decimation Factor*6)[kHz]
        /// - 011b: f_IF = -f_xosc/(Decimation Factor*8)[kHz]
        /// - 100b: Zero-IF
        /// - 101b: f_IF = f_xosc/(Decimation Factor*4)[kHz]
        /// - 110b: f_IF = f_xosc/(Decimation Factor*6)[kHz]
        /// - 111b: f_IF = f_xosc/(Decimation Factor*8)[kHz]
        ///
        /// The default value is 0x00
        pub cmix_cfg, set_cmix_cfg: 4, 2;

        /// For test purposes only, use values from SmartRF Studio.
        pub if_mix_cfg_reserved1, set_if_mix_cfg_reserved1: 1;

        /// For test purposes only, use values from SmartRF Studio.
        pub if_mix_cfg_reserved0, set_if_mix_cfg_reserved0: 0;
    }

    impl const Register for IfMixCfg {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F00);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for IfMixCfg {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for IfMixCfg {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for IfMixCfg {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for IfMixCfg {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Frequency Offset Correction Configuration
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct FreqoffCfg(u8);

        pub freqoff_cfg_not_used, _: 7, 6;

        /// Frequency offset correction enable
        ///
        /// # Values
        ///
        /// - false: Frequency offset correction disabled
        /// - true: Frequency offset correction enabled
        ///
        /// The default value is 0x01
        pub foc_en, set_foc_en: 5;

        /// Frequency offset correction configuration. FOC_CFG != 00b enables a narrower RX filter BW than FOC_CFG = 00b but needs longer settle time. When FOC in FS is enabled, the device automatically switch to 'FOC after channel filter' when a sync word is detected.
        foc_cfg_bits, set_foc_cfg_bits: 4, 3;

        /// FOC limit. This is the maximum frequency offset correction in the frequency synthesizer. Only valid when FOC_CFG != 00b
        ///
        /// # Values
        ///
        /// - false: RX filter bandwidth/4
        /// - true: RX filter bandwidth/8
        ///
        /// The default value is 0x00
        pub foc_limit, set_foc_limit: 2;

        /// Frequency offset correction<BR/>
        /// MDMCFG0.TRANSPARENT_MODE_EN | FOC_KI_FACTOR
        ///
        /// # Values
        ///
        /// - 000b: Frequency offset compensation disabled after sync detected (typical setting for short packets)
        /// - 001b: Frequency offset compensation during packet reception with loop gain factor = 1/32 (fast loop)
        /// - 010b: Frequency offset compensation during packet reception with loop gain factor = 1/64
        /// - 011b: Frequency offset compensation during packet reception with loop gain factor = 1/128 (slow loop)
        /// - 100b: Frequency offset compensation with Loop Gain factor 1/128 (fast loop)
        /// - 101b: Frequency offset compensation with Loop Gain factor 1/256
        /// - 110b: Frequency offset compensation with Loop Gain factor 1/512
        /// - 111b: Frequency offset compensation with Loop Gain factor 1/1024 (slow loop)
        ///
        /// The default value is 0x00
        pub foc_ki_factor, set_foc_ki_factor: 1, 0;
    }

    impl FreqoffCfg {
        pub fn foc_cfg(&self) -> FocCfgValue {
            unsafe { transmute(self.foc_cfg_bits()) }
        }

        pub fn set_foc_cfg(&mut self, value: FocCfgValue) {
            self.set_foc_cfg_bits(value as u8);
        }
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum FocCfgValue {
        /// FOC after channel filter (typical 0 - 1 preamble bytes for settling)
        FocAfterChannelFilter = 0b00,
        /// FOC in FS enabled. Loop gain factor is 1/128 (typical 2 - 4 preamble bytes for settling)
        FocInFsEnabledFactorOneOver128 = 0b01,
        /// FOC in FS enabled. Loop gain factor is 1/256 (typical 2 - 4 preamble bytes for settling)
        FocInFsEnabledFactorOneOver256 = 0b10,
        /// FOC in FS enabled. Loop gain factor is 1/512 (typical 2 - 4 preamble bytes for settling)
        FocInFsEnabledFactorOneOver512 = 0b11,
    }

    impl const Register for FreqoffCfg {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F01);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for FreqoffCfg {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for FreqoffCfg {
        fn default() -> Self {
            Self(0x20)
        }
    }

    impl core::fmt::Debug for FreqoffCfg {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for FreqoffCfg {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Timing Offset Correction Configuration
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct TocCfg(u8);

        /// Timing offset correction limit. TOC_LIMIT specifies maximum symbol rate offset the receiver is able to handle. TOC_LIMIT != 00b requires 2 - 4 bytes preamble for symbol rate offset compensation
        toc_limit_bits, set_toc_limit_bits: 7, 6;

        /// When TOC_LIMIT = 0 the receiver uses a block based time offset error calculation algorithm where the block length is configurable through register TOC_CFG. Before a sync word is found (SYNC_EVENT is asserted) the TOC_PRE_SYNC_BLOCKLEN sets the actual block length used for the time offset algorithm<BR/>
        ///
        /// # Values
        ///
        /// - 0b: Symbol by Symbol Timing Error Proportional Scale Factor
        ///
        /// The default value is 0x01
        pub toc_pre_sync_blocklen, set_toc_pre_sync_blocklen: 5, 3;

        /// When TOC_LIMIT = 0 the receiver uses a block based time offset error calculation algorithm where the block length is configurable through register TOC_CFG. After a sync word is found (SYNC_EVENT is asserted) the TOC_POST_SYNC_BLOCKLEN sets the actual block length used for the time offset algorithm<BR/>
        ///
        /// # Values
        ///
        /// - 0b: Symbol by Symbol Timing Error Integral Scale Factor
        ///
        /// The default value is 0x03
        pub toc_post_sync_blocklen, set_toc_post_sync_blocklen: 2, 0;
    }

    impl TocCfg {
        pub fn toc_limit(&self) -> TocLimitValue {
            unsafe { transmute(self.toc_limit_bits()) }
        }

        pub fn set_toc_limit(&mut self, value: TocLimitValue) {
            self.set_toc_limit_bits(value as u8);
        }
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum TocLimitValue {
        /// < 0.2 %
        Below2000Ppm = 0b00,
        /// < 2 %
        Below2Pct = 0b01,
        /// Reserved
        Reserved_10 = 0b10,
        /// < 12 % (MDMCFG1.CARRIER_SENSE_GATE must be set)
        Below12Pct = 0b11,
    }

    impl const Register for TocCfg {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F02);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for TocCfg {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for TocCfg {
        fn default() -> Self {
            Self(0x0b)
        }
    }

    impl core::fmt::Debug for TocCfg {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for TocCfg {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// MARC Spare
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct MarcSpare(u8);

        pub marc_spare_not_used, _: 7, 4;

        /// High level commands used to accelerate AES operations on the FIFO content
        ///
        /// # Values
        ///
        /// - 1000b: Reserved
        /// - 1001b: AES_TXFIFO
        /// - 1010b: AES_RXFIFO
        /// - 1111b: Reserved
        ///
        /// The default value is 0x00
        pub aes_commands, set_aes_commands: 3, 0;
    }

    impl const Register for MarcSpare {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F03);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for MarcSpare {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for MarcSpare {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for MarcSpare {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for MarcSpare {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// External Clock Frequency Configuration
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct EcgCfg(u8);

        pub ecg_cfg_not_used, _: 7, 5;

        /// External clock frequency. Controls division factor
        ///
        /// # Values
        ///
        /// - 00000b: 64
        /// - 00001b: 62
        /// - 00010b: 60
        /// - 00011b: 58
        /// - 00100b: 56
        /// - 00101b: 54
        /// - 00110b: 52
        /// - 00111b: 50
        /// - 01000b: 48
        /// - 01001b: 46
        /// - 01010b: 44
        /// - 01011b: 42
        /// - 01100b: 40
        /// - 01101b: 38
        /// - 01110b: 36
        /// - 01111b: 34
        /// - 10000b: 32
        /// - 10001b: 30
        /// - 10010b: 28
        /// - 10011b: 26
        /// - 10100b: 24
        /// - 10101b: 22
        /// - 10110b: 20
        /// - 10111b: 18
        /// - 11000b: 16
        /// - 11001b: 14
        /// - 11010b: 12
        /// - 11011b: 10
        /// - 11100b: 8
        /// - 11101b: 6
        /// - 11110b: 4
        /// - 11111b: 3
        ///
        /// The default value is 0x00
        pub ext_clock_freq, set_ext_clock_freq: 4, 0;
    }

    impl const Register for EcgCfg {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F04);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for EcgCfg {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for EcgCfg {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for EcgCfg {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for EcgCfg {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// General Modem Parameter Configuration Reg. 2
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Mdmcfg2(u8);

        /// Sets the resolution of an ASK bit transition (# of points). The following rule must be satisfied:<BR/>
        ///
        /// # Values
        ///
        /// - 3b: MDMCFG2.UPSAMPLER_P = 4 - PA_CFG0.RAMP_SHAPE + ASK_SHAPE<BR/>
        /// - 3b: MDMCFG2.UPSAMPLER_P = 5 - PA_CFG0.RAMP_SHAPE + ASK_SHAPE
        /// - 00b: 8
        /// - 01b: 16
        /// - 10b: 32
        /// - 11b: 128
        ///
        /// The default value is 0x00
        pub ask_shape, set_ask_shape: 7, 6;

        /// Symbol map configuration. Configures the modulated symbol mapping definition from data bit to modulated symbols. For 2'ary modulation schemes the symbol mapping definition is as follows:
        pub symbol_map_cfg, set_symbol_map_cfg: 5, 4;

        /// UPSAMPLER_P configures the variable upsampling factor P for the TX upsampler. The total upsampling factor = 16*P. The upsampler factor P must satisfy the following:<BR/>
        /// Symbol Rate*16*P < f_xosc/4, , where P should be as large as possible<BR/>
        /// The upsampler reduces repetitive spectrum at 16*symbol rate
        upsampler_p_bits, set_upsampler_p_bits: 3, 1;

        /// Custom frequency modulation enable
        ///
        /// # Values
        ///
        /// - false: CFM mode disabled
        /// - true: CFM mode enabled (write frequency word directly)
        ///
        /// The default value is 0x00
        pub cfm_data_en, set_cfm_data_en: 0;
    }

    impl Mdmcfg2 {
        pub fn upsampler_p(&self) -> UpsamplerPValue {
            unsafe { transmute(self.upsampler_p_bits()) }
        }

        pub fn set_upsampler_p(&mut self, value: UpsamplerPValue) {
            self.set_upsampler_p_bits(value as u8);
        }
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum UpsamplerPValue {
        /// TX upsampler factor P = 1 (bypassed)
        TxUpsamplerFactorPEqual1 = 0b000,
        /// TX upsampler factor P = 2
        TxUpsamplerFactorPEqual2 = 0b001,
        /// TX upsampler factor P = 4
        TxUpsamplerFactorPEqual4 = 0b010,
        /// TX upsampler factor P = 8
        TxUpsamplerFactorPEqual8 = 0b011,
        /// TX upsampler factor P = 16
        TxUpsamplerFactorPEqual16 = 0b100,
        /// TX upsampler factor P = 32
        TxUpsamplerFactorPEqual32 = 0b101,
        /// TX upsampler factor P = 64
        TxUpsamplerFactorPEqual64 = 0b110,
        /// Not used
        NotUsed = 0b111,
    }

    impl const Register for Mdmcfg2 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F05);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Mdmcfg2 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Mdmcfg2 {
        fn default() -> Self {
            Self(0x08)
        }
    }

    impl core::fmt::Debug for Mdmcfg2 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Mdmcfg2 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// External Control Configuration
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct ExtCtrl(u8);

        pub ext_ctrl_not_used, _: 7, 3;

        /// Pin control enable. Pin control reuses the SPI interface pins to execute SRX, STX, SPWD, and IDLE strobes
        ///
        /// # Values
        ///
        /// - false: Pin control disabled
        /// - true: Pin control enabled
        ///
        /// The default value is 0x00
        pub pin_ctrl_en, set_pin_ctrl_en: 2;

        /// External 40k clock enable
        ///
        /// # Values
        ///
        /// - false: External 40k clock disabled
        /// - true: External 40k clock enabled. IOCFG3.GPIO3_CFG must be set to HIGHZ (EXT_40K_CLOCK)
        ///
        /// The default value is 0x00
        pub ext_40k_clock_en, set_ext_40k_clock_en: 1;

        /// Burst address increment enable
        ///
        /// # Values
        ///
        /// - false: Burst address increment disabled (i.e. consecutive writes to the same address location in burst mode)
        /// - true: Burst address increment enabled (i.e. the address is incremented during burst access)
        ///
        /// The default value is 0x01
        pub burst_addr_incr_en, set_burst_addr_incr_en: 0;
    }

    impl const Register for ExtCtrl {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F06);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for ExtCtrl {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for ExtCtrl {
        fn default() -> Self {
            Self(0x01)
        }
    }

    impl core::fmt::Debug for ExtCtrl {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for ExtCtrl {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// RC Oscillator Calibration Fine
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct RccalFine(u8);

        pub rccal_fine_not_used, _: 7;

        /// 40 kHz RCOSC calibrated fine value
        pub rcc_fine, set_rcc_fine: 6, 0;
    }

    impl const Register for RccalFine {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F07);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for RccalFine {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for RccalFine {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for RccalFine {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for RccalFine {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// RC Oscillator Calibration Coarse
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct RccalCoarse(u8);

        pub rccal_coarse_not_used, _: 7;

        /// 40 kHz RCOSC calibrated coarse value
        pub rcc_coarse, set_rcc_coarse: 6, 0;
    }

    impl const Register for RccalCoarse {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F08);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for RccalCoarse {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for RccalCoarse {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for RccalCoarse {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for RccalCoarse {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// RC Oscillator Calibration Clock Offset
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct RccalOffset(u8);

        pub rccal_offset_not_used, _: 7, 5;

        /// For test purposes only, use values from SmartRF Studio.
        pub rccal_offset_reserved4_0, set_rccal_offset_reserved4_0: 4, 0;
    }

    impl const Register for RccalOffset {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F09);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for RccalOffset {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for RccalOffset {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for RccalOffset {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for RccalOffset {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Frequency Offset MSB
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Freqoff1(u8);

        /// Frequency offset [15:8]. Updated by user or SAFC strobe. The value is in two's complement format
        pub freq_off_15_8, set_freq_off_15_8: 7, 0;
    }

    impl const Register for Freqoff1 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F0A);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Freqoff1 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Freqoff1 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for Freqoff1 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Freqoff1 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Frequency Offset LSB
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Freqoff0(u8);

        /// Frequency offset [7:0]. Updated by user or SAFC strobe. The value is in two's complement format
        pub freq_off_7_0, set_freq_off_7_0: 7, 0;
    }

    impl const Register for Freqoff0 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F0B);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Freqoff0 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Freqoff0 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for Freqoff0 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Freqoff0 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Frequency Configuration [23:16]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Freq2(u8);

        /// Frequency [23:16]<BR/>
        /// f_RF = f_vco/LO Divider [Hz] where f_vco = (FREQ/(2^16)*f_xosc) + (FREQOFF/(2^18)*f_xosc) [Hz] and the LO Divider is given by FS_CFG.FSD_BANDSELECT
        pub freq_23_16, set_freq_23_16: 7, 0;
    }

    impl const Register for Freq2 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F0C);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Freq2 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Freq2 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for Freq2 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Freq2 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Frequency Configuration [15:8]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Freq1(u8);

        /// Frequency [15:8]. See FREQ2
        pub freq_15_8, set_freq_15_8: 7, 0;
    }

    impl const Register for Freq1 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F0D);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Freq1 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Freq1 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for Freq1 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Freq1 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Frequency Configuration [7:0]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Freq0(u8);

        /// Frequency [7:0]. See FREQ2
        pub freq_7_0, set_freq_7_0: 7, 0;
    }

    impl const Register for Freq0 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F0E);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Freq0 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Freq0 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for Freq0 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Freq0 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Analog to Digital Converter Configuration Reg. 2
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct IfAdc2(u8);

        pub if_adc2_not_used, _: 7, 4;

        /// For test purposes only, use values from SmartRF Studio.
        pub if_adc2_reserved3_0, set_if_adc2_reserved3_0: 3, 0;
    }

    impl const Register for IfAdc2 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F0F);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for IfAdc2 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for IfAdc2 {
        fn default() -> Self {
            Self(0x02)
        }
    }

    impl core::fmt::Debug for IfAdc2 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for IfAdc2 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Analog to Digital Converter Configuration Reg. 1
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct IfAdc1(u8);

        /// For test purposes only, use values from SmartRF Studio.
        pub if_adc1_reserved7_6, set_if_adc1_reserved7_6: 7, 6;

        /// For test purposes only, use values from SmartRF Studio.
        pub if_adc1_reserved5_4, set_if_adc1_reserved5_4: 5, 4;

        /// For test purposes only, use values from SmartRF Studio.
        pub if_adc1_reserved3_2, set_if_adc1_reserved3_2: 3, 2;

        /// For test purposes only, use values from SmartRF Studio.
        pub if_adc1_reserved1_0, set_if_adc1_reserved1_0: 1, 0;
    }

    impl const Register for IfAdc1 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F10);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for IfAdc1 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for IfAdc1 {
        fn default() -> Self {
            Self(0x5a)
        }
    }

    impl core::fmt::Debug for IfAdc1 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for IfAdc1 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Analog to Digital Converter Configuration Reg. 0
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct IfAdc0(u8);

        pub if_adc0_not_used, _: 7, 6;

        /// For test purposes only, use values from SmartRF Studio.
        pub if_adc0_reserved5_3, set_if_adc0_reserved5_3: 5, 3;

        /// For test purposes only, use values from SmartRF Studio.
        pub if_adc0_reserved2_1, set_if_adc0_reserved2_1: 2, 1;

        /// For test purposes only, use values from SmartRF Studio.
        pub if_adc0_reserved0, set_if_adc0_reserved0: 0;
    }

    impl const Register for IfAdc0 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F11);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for IfAdc0 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for IfAdc0 {
        fn default() -> Self {
            Self(0x1a)
        }
    }

    impl core::fmt::Debug for IfAdc0 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for IfAdc0 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Frequency Synthesizer Digital Reg. 1
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct FsDig1(u8);

        pub fs_dig1_not_used, _: 7, 6;

        /// Loop-filter switch configuration 1
        pub fsd_lpf_switch1_en, set_fsd_lpf_switch1_en: 5;

        /// Loop-filter switch configuration 2
        pub fsd_lpf_switch2_en, set_fsd_lpf_switch2_en: 4;

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_dig1_reserved3_2, set_fs_dig1_reserved3_2: 3, 2;

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_dig1_reserved1, set_fs_dig1_reserved1: 1;

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_dig1_reserved0, set_fs_dig1_reserved0: 0;
    }

    impl const Register for FsDig1 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F12);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for FsDig1 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for FsDig1 {
        fn default() -> Self {
            Self(0x08)
        }
    }

    impl core::fmt::Debug for FsDig1 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for FsDig1 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Frequency Synthesizer Digital Reg. 0
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct FsDig0(u8);

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_dig0_reserved7_6, set_fs_dig0_reserved7_6: 7, 6;

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_dig0_reserved5_4, set_fs_dig0_reserved5_4: 5, 4;

        /// FS loop bandwidth in RX
        rx_lpf_bw_bits, set_rx_lpf_bw_bits: 3, 2;

        /// FS loop bandwidth in TX
        tx_lpf_bw_bits, set_tx_lpf_bw_bits: 1, 0;
    }

    impl FsDig0 {
        pub fn rx_lpf_bw(&self) -> RxLpfBwValue {
            unsafe { transmute(self.rx_lpf_bw_bits()) }
        }

        pub fn set_rx_lpf_bw(&mut self, value: RxLpfBwValue) {
            self.set_rx_lpf_bw_bits(value as u8);
        }
        pub fn tx_lpf_bw(&self) -> TxLpfBwValue {
            unsafe { transmute(self.tx_lpf_bw_bits()) }
        }

        pub fn set_tx_lpf_bw(&mut self, value: TxLpfBwValue) {
            self.set_tx_lpf_bw_bits(value as u8);
        }
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum RxLpfBwValue {
        /// 200 kHz
        Khz200 = 0b00,
        /// 300 kHz
        Khz300 = 0b01,
        /// 400 kHz
        Khz400 = 0b10,
        /// 500 kHz
        Khz500 = 0b11,
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum TxLpfBwValue {
        /// 200 kHz
        Khz200 = 0b00,
        /// 300 kHz
        Khz300 = 0b01,
        /// 400 kHz
        Khz400 = 0b10,
        /// 500 kHz
        Khz500 = 0b11,
    }

    impl const Register for FsDig0 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F13);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for FsDig0 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for FsDig0 {
        fn default() -> Self {
            Self(0x5a)
        }
    }

    impl core::fmt::Debug for FsDig0 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for FsDig0 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Frequency Synthesizer Calibration Reg. 3
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct FsCal3(u8);

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_cal3_reserved7, set_fs_cal3_reserved7: 7;

        /// KVCO high resolution enable
        ///
        /// # Values
        ///
        /// - false: High resolution disabled (normal resolution mode)
        /// - true: High resolution enabled (increased charge pump calibration, but will extend the calibration time)
        ///
        /// The default value is 0x00
        pub kvco_high_res_cfg, set_kvco_high_res_cfg: 6;

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_cal3_reserved5_4, set_fs_cal3_reserved5_4: 5, 4;

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_cal3_reserved3_0, set_fs_cal3_reserved3_0: 3, 0;
    }

    impl const Register for FsCal3 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F14);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for FsCal3 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for FsCal3 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for FsCal3 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for FsCal3 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Frequency Synthesizer Calibration Reg. 2
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct FsCal2(u8);

        pub fs_cal2_not_used, _: 7, 6;

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_cal2_reserved5_0, set_fs_cal2_reserved5_0: 5, 0;
    }

    impl const Register for FsCal2 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F15);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for FsCal2 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for FsCal2 {
        fn default() -> Self {
            Self(0x20)
        }
    }

    impl core::fmt::Debug for FsCal2 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for FsCal2 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Frequency Synthesizer Calibration Reg. 1
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct FsCal1(u8);

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_cal1_reserved7_6, set_fs_cal1_reserved7_6: 7, 6;

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_cal1_reserved5_4, set_fs_cal1_reserved5_4: 5, 4;

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_cal1_reserved3_2, set_fs_cal1_reserved3_2: 3, 2;

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_cal1_reserved1_0, set_fs_cal1_reserved1_0: 1, 0;
    }

    impl const Register for FsCal1 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F16);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for FsCal1 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for FsCal1 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for FsCal1 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for FsCal1 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Frequency Synthesizer Calibration Reg. 0
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct FsCal0(u8);

        pub fs_cal0_not_used, _: 7, 4;

        /// Out of lock detector average time
        lock_cfg_bits, set_lock_cfg_bits: 3, 2;

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_cal0_reserved1_0, set_fs_cal0_reserved1_0: 1, 0;
    }

    impl FsCal0 {
        pub fn lock_cfg(&self) -> LockCfgValue {
            unsafe { transmute(self.lock_cfg_bits()) }
        }

        pub fn set_lock_cfg(&mut self, value: LockCfgValue) {
            self.set_lock_cfg_bits(value as u8);
        }
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum LockCfgValue {
        /// Average the measurement over 512 cycles
        AverageTheMeasurementOver512Cycles = 0b00,
        /// Average the measurement over 1024 cycles
        AverageTheMeasurementOver1024Cycles = 0b01,
        /// Average the measurement over 256 cycles
        AverageTheMeasurementOver256Cycles = 0b10,
        /// Infinite average
        InfiniteAverage = 0b11,
    }

    impl const Register for FsCal0 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F17);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for FsCal0 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for FsCal0 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for FsCal0 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for FsCal0 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Frequency Synthesizer Charge Pump Configuration
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct FsChp(u8);

        pub fs_chp_not_used, _: 7, 6;

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_chp_reserved5_0, set_fs_chp_reserved5_0: 5, 0;
    }

    impl const Register for FsChp {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F18);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for FsChp {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for FsChp {
        fn default() -> Self {
            Self(0x28)
        }
    }

    impl core::fmt::Debug for FsChp {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for FsChp {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Frequency Synthesizer Divide by 2
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct FsDivtwo(u8);

        pub fs_divtwo_not_used, _: 7, 2;

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_divtwo_reserved1_0, set_fs_divtwo_reserved1_0: 1, 0;
    }

    impl const Register for FsDivtwo {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F19);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for FsDivtwo {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for FsDivtwo {
        fn default() -> Self {
            Self(0x01)
        }
    }

    impl core::fmt::Debug for FsDivtwo {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for FsDivtwo {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// FS Digital Synthesizer Module Configuration Reg. 1
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct FsDsm1(u8);

        pub fs_dsm1_not_used, _: 7, 3;

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_dsm1_reserved2, set_fs_dsm1_reserved2: 2;

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_dsm1_reserved1_0, set_fs_dsm1_reserved1_0: 1, 0;
    }

    impl const Register for FsDsm1 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F1A);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for FsDsm1 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for FsDsm1 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for FsDsm1 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for FsDsm1 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// FS Digital Synthesizer Module Configuration Reg. 0
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct FsDsm0(u8);

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_dsm0_reserved7_4, set_fs_dsm0_reserved7_4: 7, 4;

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_dsm0_reserved3, set_fs_dsm0_reserved3: 3;

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_dsm0_reserved2_0, set_fs_dsm0_reserved2_0: 2, 0;
    }

    impl const Register for FsDsm0 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F1B);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for FsDsm0 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for FsDsm0 {
        fn default() -> Self {
            Self(0x03)
        }
    }

    impl core::fmt::Debug for FsDsm0 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for FsDsm0 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Frequency Synthesizer Divider Chain Configuration Reg. 1
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct FsDvc1(u8);

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_dvc1_reserved7_6, set_fs_dvc1_reserved7_6: 7, 6;

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_dvc1_reserved5_4, set_fs_dvc1_reserved5_4: 5, 4;

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_dvc1_reserved3_2, set_fs_dvc1_reserved3_2: 3, 2;

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_dvc1_reserved1_0, set_fs_dvc1_reserved1_0: 1, 0;
    }

    impl const Register for FsDvc1 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F1C);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for FsDvc1 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for FsDvc1 {
        fn default() -> Self {
            Self(0xff)
        }
    }

    impl core::fmt::Debug for FsDvc1 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for FsDvc1 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Frequency Synthesizer Divider Chain Configuration Reg. 0
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct FsDvc0(u8);

        pub fs_dvc0_not_used, _: 7, 5;

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_dvc0_reserved4_3, set_fs_dvc0_reserved4_3: 4, 3;

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_dvc0_reserved2_0, set_fs_dvc0_reserved2_0: 2, 0;
    }

    impl const Register for FsDvc0 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F1D);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for FsDvc0 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for FsDvc0 {
        fn default() -> Self {
            Self(0x1f)
        }
    }

    impl core::fmt::Debug for FsDvc0 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for FsDvc0 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Frequency Synthesizer Local Bias Configuration
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct FsLbi(u8);

        pub fs_lbi_not_used, _: 7, 0;
    }

    impl const Register for FsLbi {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F1E);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for FsLbi {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for FsLbi {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for FsLbi {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for FsLbi {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Frequency Synthesizer Phase Frequency Detector Configuration
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct FsPfd(u8);

        pub fsd_pfd_not_used, _: 7;

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_pfd_reserved6_4, set_fs_pfd_reserved6_4: 6, 4;

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_pfd_reserved3_2, set_fs_pfd_reserved3_2: 3, 2;

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_pfd_reserved1_0, set_fs_pfd_reserved1_0: 1, 0;
    }

    impl const Register for FsPfd {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F1F);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for FsPfd {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for FsPfd {
        fn default() -> Self {
            Self(0x51)
        }
    }

    impl core::fmt::Debug for FsPfd {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for FsPfd {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Frequency Synthesizer Prescaler Configuration
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct FsPre(u8);

        pub fs_pre_not_used, _: 7;

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_pre_reserved6_5, set_fs_pre_reserved6_5: 6, 5;

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_pre_reserved4_3, set_fs_pre_reserved4_3: 4, 3;

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_pre_reserved2_0, set_fs_pre_reserved2_0: 2, 0;
    }

    impl const Register for FsPre {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F20);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for FsPre {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for FsPre {
        fn default() -> Self {
            Self(0x2c)
        }
    }

    impl core::fmt::Debug for FsPre {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for FsPre {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Frequency Synthesizer Divider Regulator Configuration
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct FsRegDivCml(u8);

        pub fs_reg_div_cml_not_used, _: 7, 5;

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_reg_div_cml_reserved4_2, set_fs_reg_div_cml_reserved4_2: 4, 2;

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_reg_div_cml_reserved1_0, set_fs_reg_div_cml_reserved1_0: 1, 0;
    }

    impl const Register for FsRegDivCml {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F21);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for FsRegDivCml {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for FsRegDivCml {
        fn default() -> Self {
            Self(0x11)
        }
    }

    impl core::fmt::Debug for FsRegDivCml {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for FsRegDivCml {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Frequency Synthesizer Spare
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct FsSpare(u8);

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_spare_reserved7_0, set_fs_spare_reserved7_0: 7, 0;
    }

    impl const Register for FsSpare {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F22);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for FsSpare {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for FsSpare {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for FsSpare {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for FsSpare {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// FS Voltage Controlled Oscillator Configuration Reg. 4
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct FsVco4(u8);

        pub fs_vco4_not_used, _: 7, 5;

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_vco4_reserved4_0, set_fs_vco4_reserved4_0: 4, 0;
    }

    impl const Register for FsVco4 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F23);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for FsVco4 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for FsVco4 {
        fn default() -> Self {
            Self(0x14)
        }
    }

    impl core::fmt::Debug for FsVco4 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for FsVco4 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// FS Voltage Controlled Oscillator Configuration Reg. 3
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct FsVco3(u8);

        pub fs_vco3_not_used, _: 7, 1;

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_vco3_reserved0, set_fs_vco3_reserved0: 0;
    }

    impl const Register for FsVco3 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F24);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for FsVco3 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for FsVco3 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for FsVco3 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for FsVco3 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// FS Voltage Controlled Oscillator Configuration Reg. 2
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct FsVco2(u8);

        pub fs_vco2_not_used, _: 7;

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_vco2_reserved6_0, set_fs_vco2_reserved6_0: 6, 0;
    }

    impl const Register for FsVco2 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F25);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for FsVco2 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for FsVco2 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for FsVco2 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for FsVco2 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// FS Voltage Controlled Oscillator Configuration Reg. 1
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct FsVco1(u8);

        /// VCO VCDAC configuration. Used in open-loop CAL mode.  Note that avdd is the internal VCO regulated voltage
        ///
        /// # Values
        ///
        /// - 000000b: VCDAC out = min 160 mV
        /// - 111111b: VCDAC out = max avdd - 160 mV
        ///
        /// The default value is 0x00
        pub fsd_vcdac, set_fsd_vcdac: 7, 2;

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_vco1_reserved1_0, set_fs_vco1_reserved1_0: 1, 0;
    }

    impl const Register for FsVco1 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F26);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for FsVco1 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for FsVco1 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for FsVco1 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for FsVco1 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// FS Voltage Controlled Oscillator Configuration Reg. 0
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct FsVco0(u8);

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_vco0_reserved7, set_fs_vco0_reserved7: 7;

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_vco0_reserved6_2, set_fs_vco0_reserved6_2: 6, 2;

        /// For test purposes only, use values from SmartRF Studio.
        pub fs_vco0_reserved1_0, set_fs_vco0_reserved1_0: 1, 0;
    }

    impl const Register for FsVco0 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F27);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for FsVco0 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for FsVco0 {
        fn default() -> Self {
            Self(0x81)
        }
    }

    impl core::fmt::Debug for FsVco0 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for FsVco0 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Global Bias Configuration Reg. 6
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Gbias6(u8);

        pub gbias6_not_used, _: 7, 6;

        /// For test purposes only, use values from SmartRF Studio.
        pub gbias6_reserved5_0, set_gbias6_reserved5_0: 5, 0;
    }

    impl const Register for Gbias6 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F28);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Gbias6 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Gbias6 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for Gbias6 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Gbias6 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Global Bias Configuration Reg. 5
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Gbias5(u8);

        pub gbias5_not_used, _: 7, 4;

        /// For test purposes only, use values from SmartRF Studio.
        pub gbias5_reserved3_0, set_gbias5_reserved3_0: 3, 0;
    }

    impl const Register for Gbias5 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F29);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Gbias5 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Gbias5 {
        fn default() -> Self {
            Self(0x02)
        }
    }

    impl core::fmt::Debug for Gbias5 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Gbias5 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Global Bias Configuration Reg. 4
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Gbias4(u8);

        pub gbias4_not_used, _: 7, 6;

        /// For test purposes only, use values from SmartRF Studio.
        pub gbias4_reserved5_0, set_gbias4_reserved5_0: 5, 0;
    }

    impl const Register for Gbias4 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F2A);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Gbias4 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Gbias4 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for Gbias4 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Gbias4 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Global Bias Configuration Reg. 3
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Gbias3(u8);

        pub gbias3_not_used, _: 7, 6;

        /// For test purposes only, use values from SmartRF Studio.
        pub gbias3_reserved5_0, set_gbias3_reserved5_0: 5, 0;
    }

    impl const Register for Gbias3 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F2B);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Gbias3 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Gbias3 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for Gbias3 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Gbias3 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Global Bias Configuration Reg. 2
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Gbias2(u8);

        pub gbias2_not_used, _: 7;

        /// For test purposes only, use values from SmartRF Studio.
        pub gbias2_reserved6_3, set_gbias2_reserved6_3: 6, 3;

        /// For test purposes only, use values from SmartRF Studio.
        pub gbias2_reserved2_0, set_gbias2_reserved2_0: 2, 0;
    }

    impl const Register for Gbias2 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F2C);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Gbias2 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Gbias2 {
        fn default() -> Self {
            Self(0x10)
        }
    }

    impl core::fmt::Debug for Gbias2 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Gbias2 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Global Bias Configuration Reg. 1
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Gbias1(u8);

        pub gbias1_not_used, _: 7, 5;

        /// For test purposes only, use values from SmartRF Studio.
        pub gbias1_reserved4_0, set_gbias1_reserved4_0: 4, 0;
    }

    impl const Register for Gbias1 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F2D);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Gbias1 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Gbias1 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for Gbias1 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Gbias1 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Global Bias Configuration Reg. 0
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Gbias0(u8);

        pub gbias0_not_used, _: 7, 2;

        /// For test purposes only, use values from SmartRF Studio.
        pub gbias0_reserved1, set_gbias0_reserved1: 1;

        /// For test purposes only, use values from SmartRF Studio.
        pub gbias0_reserved0, set_gbias0_reserved0: 0;
    }

    impl const Register for Gbias0 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F2E);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Gbias0 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Gbias0 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for Gbias0 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Gbias0 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Intermediate Frequency Amplifier Configuration
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Ifamp(u8);

        pub ifamp_not_used, _: 7, 4;

        /// Single side bandwidth control bits covering frequency range from 300 kHz to 1500 kHz. Single Side BW > f_IF+(RX Filter BW/2)
        ifamp_bw_bits, set_ifamp_bw_bits: 3, 2;

        /// For test purposes only, use values from SmartRF Studio.
        pub ifamp_reserved1_0, set_ifamp_reserved1_0: 1, 0;
    }

    impl Ifamp {
        pub fn ifamp_bw(&self) -> IfampBwValue {
            unsafe { transmute(self.ifamp_bw_bits()) }
        }

        pub fn set_ifamp_bw(&mut self, value: IfampBwValue) {
            self.set_ifamp_bw_bits(value as u8);
        }
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum IfampBwValue {
        /// 300 kHz
        Khz300 = 0b00,
        /// 600 kHz
        Khz600 = 0b01,
        /// 1000 kHz
        Khz1000 = 0b10,
        /// 1500 kHz
        Khz1500 = 0b11,
    }

    impl const Register for Ifamp {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F2F);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Ifamp {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Ifamp {
        fn default() -> Self {
            Self(0x01)
        }
    }

    impl core::fmt::Debug for Ifamp {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Ifamp {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Low Noise Amplifier Configuration
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Lna(u8);

        pub lna_not_used, _: 7, 2;

        /// For test purposes only, use values from SmartRF Studio.
        pub lna_reserved1_0, set_lna_reserved1_0: 1, 0;
    }

    impl const Register for Lna {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F30);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Lna {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Lna {
        fn default() -> Self {
            Self(0x01)
        }
    }

    impl core::fmt::Debug for Lna {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Lna {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// RX Mixer Configuration
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Rxmix(u8);

        pub rxmix_not_used, _: 7, 2;

        /// For test purposes only, use values from SmartRF Studio.
        pub rxmix_reserved1_0, set_rxmix_reserved1_0: 1, 0;
    }

    impl const Register for Rxmix {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F31);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Rxmix {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Rxmix {
        fn default() -> Self {
            Self(0x01)
        }
    }

    impl core::fmt::Debug for Rxmix {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Rxmix {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Crystal Oscillator Configuration Reg. 5
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Xosc5(u8);

        pub xosc5_not_used, _: 7, 4;

        /// For test purposes only, use values from SmartRF Studio.
        pub xosc5_reserved3_0, set_xosc5_reserved3_0: 3, 0;
    }

    impl const Register for Xosc5 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F32);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Xosc5 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Xosc5 {
        fn default() -> Self {
            Self(0x0c)
        }
    }

    impl core::fmt::Debug for Xosc5 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Xosc5 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Crystal Oscillator Configuration Reg. 4
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Xosc4(u8);

        /// For test purposes only, use values from SmartRF Studio.
        pub xosc4_reserved7_0, set_xosc4_reserved7_0: 7, 0;
    }

    impl const Register for Xosc4 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F33);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Xosc4 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Xosc4 {
        fn default() -> Self {
            Self(0xa0)
        }
    }

    impl core::fmt::Debug for Xosc4 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Xosc4 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Crystal Oscillator Configuration Reg. 3
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Xosc3(u8);

        /// For test purposes only, use values from SmartRF Studio.
        pub xosc3_reserved7_2, set_xosc3_reserved7_2: 7, 2;

        /// For test purposes only, use values from SmartRF Studio.
        pub xosc3_reserved1_0, set_xosc3_reserved1_0: 1, 0;
    }

    impl const Register for Xosc3 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F34);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Xosc3 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Xosc3 {
        fn default() -> Self {
            Self(0x03)
        }
    }

    impl core::fmt::Debug for Xosc3 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Xosc3 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Crystal Oscillator Configuration Reg. 2
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Xosc2(u8);

        pub xosc2_not_used, _: 7, 4;

        /// For test purposes only, use values from SmartRF Studio.
        pub xosc2_reserved3_2, set_xosc2_reserved3_2: 3, 2;

        /// For test purposes only, use values from SmartRF Studio.
        pub xosc2_reserved1, set_xosc2_reserved1: 1;

        ///
        /// # Values
        ///
        /// - false: The XOSC will be turned off if the SXOFF, SPWD, or SWOR command strobes are issued
        /// - true: The XOSC is forced on even if an SXOFF, SPWD, or SWOR command strobe has been issued. This can be used to enable fast start-up from SLEEP/XOFF on the expense of a higher current consumption
        ///
        /// The default value is 0x00
        pub xosc_core_pd_override, set_xosc_core_pd_override: 0;
    }

    impl const Register for Xosc2 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F35);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Xosc2 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Xosc2 {
        fn default() -> Self {
            Self(0x04)
        }
    }

    impl core::fmt::Debug for Xosc2 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Xosc2 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Crystal Oscillator Configuration Reg. 1
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Xosc1(u8);

        pub xosc1_not_used, _: 7, 3;

        /// For test purposes only, use values from SmartRF Studio.
        pub xosc1_reserved2, set_xosc1_reserved2: 2;

        /// XOSC buffer select. Selects internal XOSC buffer for RF PLL
        ///
        /// # Values
        ///
        /// - false: Low power, single ended buffer (differential buffer is shut down)
        /// - true: Low phase noise, differential buffer (low power buffer still used for digital clock)
        ///
        /// The default value is 0x00
        pub xosc_buf_sel, set_xosc_buf_sel: 1;

        /// XOSC is stable (has finished settling)
        pub xosc_stable, _: 0;
    }

    impl const Register for Xosc1 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F36);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Xosc1 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Xosc1 {
        fn default() -> Self {
            Self(0x01)
        }
    }

    impl core::fmt::Debug for Xosc1 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Xosc1 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Crystal Oscillator Configuration Reg. 0
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Xosc0(u8);

        pub xosc0_not_used, _: 7, 2;

        /// For test purposes only, use values from SmartRF Studio.
        pub xosc0_reserved1, _: 1;

        /// For test purposes only, use values from SmartRF Studio.
        pub xosc0_reserved0, _: 0;
    }

    impl const Register for Xosc0 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F37);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Xosc0 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Xosc0 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for Xosc0 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Xosc0 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Analog Spare
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AnalogSpare(u8);

        /// For test purposes only, use values from SmartRF Studio.
        pub analog_spare_reserved7_0, set_analog_spare_reserved7_0: 7, 0;
    }

    impl const Register for AnalogSpare {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F38);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AnalogSpare {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AnalogSpare {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for AnalogSpare {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AnalogSpare {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Power Amplifier Configuration Reg. 3
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct PaCfg3(u8);

        pub pa_cfg3_not_used, _: 7, 3;

        /// For test purposes only, use values from SmartRF Studio.
        pub pa_cfg3_reserved2_0, set_pa_cfg3_reserved2_0: 2, 0;
    }

    impl const Register for PaCfg3 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F39);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for PaCfg3 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for PaCfg3 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for PaCfg3 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for PaCfg3 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// eWOR Timer Counter Value MSB
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct WorTime1(u8);

        /// eWOR timer counter value [15:8]
        pub wor_status_15_8, _: 7, 0;
    }

    impl const Register for WorTime1 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F64);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for WorTime1 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for WorTime1 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for WorTime1 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for WorTime1 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// eWOR Timer Counter Value LSB
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct WorTime0(u8);

        /// eWOR timer counter value [7:0]
        pub wor_status_7_0, _: 7, 0;
    }

    impl const Register for WorTime0 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F65);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for WorTime0 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for WorTime0 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for WorTime0 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for WorTime0 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// eWOR Timer Capture Value MSB
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct WorCapture1(u8);

        /// eWOR timer capture value [15:8]. Capture timer value on sync detect to simplify timer re-synchronization
        pub wor_capture_15_8, _: 7, 0;
    }

    impl const Register for WorCapture1 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F66);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for WorCapture1 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for WorCapture1 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for WorCapture1 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for WorCapture1 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// eWOR Timer Capture Value LSB
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct WorCapture0(u8);

        /// eWOR timer capture Value [7:0]. Capture timer value on sync detect to simplify timer re-synchronization
        pub wor_capture_7_0, _: 7, 0;
    }

    impl const Register for WorCapture0 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F67);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for WorCapture0 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for WorCapture0 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for WorCapture0 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for WorCapture0 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// MARC Built-In Self-Test
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Bist(u8);

        pub bist_not_used, _: 7, 4;

        /// For test purposes only, use values from SmartRF Studio.
        pub bist_reserved3, set_bist_reserved3: 3;

        /// For test purposes only, use values from SmartRF Studio.
        pub bist_reserved2, _: 2;

        /// For test purposes only, use values from SmartRF Studio.
        pub bist_reserved1, _: 1;

        /// For test purposes only, use values from SmartRF Studio.
        pub bist_reserved0, set_bist_reserved0: 0;
    }

    impl const Register for Bist {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F68);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Bist {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Bist {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for Bist {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Bist {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// DC Filter Offset I MSB
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct DcfiltoffsetI1(u8);

        /// DC compensation, real value [15:8]
        pub dcfilt_offset_i_15_8, set_dcfilt_offset_i_15_8: 7, 0;
    }

    impl const Register for DcfiltoffsetI1 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F69);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for DcfiltoffsetI1 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for DcfiltoffsetI1 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for DcfiltoffsetI1 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for DcfiltoffsetI1 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// DC Filter Offset I LSB
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct DcfiltoffsetI0(u8);

        /// DC compensation, real value [7:0]
        pub dcfilt_offset_i_7_0, set_dcfilt_offset_i_7_0: 7, 0;
    }

    impl const Register for DcfiltoffsetI0 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F6A);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for DcfiltoffsetI0 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for DcfiltoffsetI0 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for DcfiltoffsetI0 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for DcfiltoffsetI0 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// DC Filter Offset Q MSB
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct DcfiltoffsetQ1(u8);

        /// DC compensation, imaginary value [15:8]
        pub dcfilt_offset_q_15_8, set_dcfilt_offset_q_15_8: 7, 0;
    }

    impl const Register for DcfiltoffsetQ1 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F6B);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for DcfiltoffsetQ1 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for DcfiltoffsetQ1 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for DcfiltoffsetQ1 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for DcfiltoffsetQ1 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// DC Filter Offset Q LSB
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct DcfiltoffsetQ0(u8);

        /// DC compensation, imaginary value [7:0]
        pub dcfilt_offset_q_7_0, set_dcfilt_offset_q_7_0: 7, 0;
    }

    impl const Register for DcfiltoffsetQ0 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F6C);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for DcfiltoffsetQ0 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for DcfiltoffsetQ0 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for DcfiltoffsetQ0 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for DcfiltoffsetQ0 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// IQ Imbalance Value I MSB
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct IqieI1(u8);

        /// IQ imbalance value, real part [15:8]
        pub iqie_i_15_8, set_iqie_i_15_8: 7, 0;
    }

    impl const Register for IqieI1 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F6D);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for IqieI1 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for IqieI1 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for IqieI1 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for IqieI1 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// IQ Imbalance Value I LSB
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct IqieI0(u8);

        /// IQ imbalance value, real part [7:0]
        pub iqie_i_7_0, set_iqie_i_7_0: 7, 0;
    }

    impl const Register for IqieI0 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F6E);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for IqieI0 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for IqieI0 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for IqieI0 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for IqieI0 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// IQ Imbalance Value Q MSB
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct IqieQ1(u8);

        /// IQ imbalance value, imaginary part [15:8]
        pub iqie_q_15_8, set_iqie_q_15_8: 7, 0;
    }

    impl const Register for IqieQ1 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F6F);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for IqieQ1 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for IqieQ1 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for IqieQ1 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for IqieQ1 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// IQ Imbalance Value Q LSB
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct IqieQ0(u8);

        /// IQ imbalance value, imaginary part [7:0]
        pub iqie_q_7_0, set_iqie_q_7_0: 7, 0;
    }

    impl const Register for IqieQ0 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F70);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for IqieQ0 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for IqieQ0 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for IqieQ0 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for IqieQ0 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Received Signal Strength Indicator Reg. 1
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Rssi1(u8);

        /// Received signal strength indicator. 8 MSB of RSSI[11:0]. RSSI[11:0] is a two's complement number with 0.0625 dB resolution hence ranging from -128 to 127 dBm. A value of -128 dBm indicates that the RSSI is invalid. To get a correct RSSI value a calibrated RSSI offset value should be subtracted from the value given by RSSI[11:0]. This RSSI offset value can either be subtracted from RSSI[11:0] manually or the offset can be written to AGC_GAIN_ADJUST.GAIN_ADJUSTMENT meaning that RSSI[11:0] will give a correct value directly
        pub rssi_11_4, _: 7, 0;
    }

    impl const Register for Rssi1 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F71);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Rssi1 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Rssi1 {
        fn default() -> Self {
            Self(0x80)
        }
    }

    impl core::fmt::Debug for Rssi1 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Rssi1 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Received Signal Strength Indicator Reg.0
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Rssi0(u8);

        pub rssi0_not_used, _: 7;

        /// Received signal strength indicator. 4 LSB of RSSI[11:0]. See RSSI1.RSSI_11_4
        pub rssi_3_0, _: 6, 3;

        /// Carrier sense
        ///
        /// # Values
        ///
        /// - false: No carrier detected
        /// - true: carrier detected
        ///
        /// The default value is 0x00
        pub carrier_sense, _: 2;

        /// Carrier sense valid
        ///
        /// # Values
        ///
        /// - false: Carrier sense not valid
        /// - true: Carrier sense valid
        ///
        /// The default value is 0x00
        pub carrier_sense_valid, _: 1;

        /// RSSI valid
        ///
        /// # Values
        ///
        /// - false: RSSI not valid
        /// - true: RSSI valid
        ///
        /// The default value is 0x00
        pub rssi_valid, _: 0;
    }

    impl const Register for Rssi0 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F72);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Rssi0 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Rssi0 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for Rssi0 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Rssi0 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// MARC State
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Marcstate(u8);

        pub marcstate_not_used, _: 7;

        /// MARC 2 pin state value
        marc_2pin_state_bits, _: 6, 5;

        pub marc_state_bits, _: 4, 0;
    }

    impl Marcstate {
        pub fn marc_2pin_state(&self) -> Marc2pinStateValue {
            unsafe { transmute(self.marc_2pin_state_bits()) }
        }
    }

    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum Marc2pinStateValue {
        /// SETTLING
        Settling = 0b00,
        /// TX
        Tx = 0b01,
        /// IDLE
        Idle = 0b10,
        /// RX
        Rx = 0b11,
    }

    impl const Register for Marcstate {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F73);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Marcstate {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Marcstate {
        fn default() -> Self {
            Self(0x41)
        }
    }

    impl core::fmt::Debug for Marcstate {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Marcstate {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Link Quality Indicator Value
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct LqiVal(u8);

        /// CRC OK. Asserted in RX when PKT_CFG1.CRC_CFG = 1 or 10b and a good packet is received. This signal is always on if the radio is in TX or if the radio is in RX and PKT_CFG1.CRC_CFG = 0. The signal is de-asserted when RX mode is entered and PKT_CFG1.CRC_CFG != 0
        ///
        /// # Values
        ///
        /// - false: CRC check not ok (bit error)
        /// - true: CRC check ok (no bit error)
        ///
        /// The default value is 0x00
        pub pkt_crc_ok, _: 7;

        /// Link quality indicator. 0 when not valid. A low value indicates a better link than what a high value does
        pub lqi, _: 6, 0;
    }

    impl const Register for LqiVal {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F74);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for LqiVal {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for LqiVal {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for LqiVal {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for LqiVal {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Preamble and Sync Word Error
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct PqtSyncErr(u8);

        /// Preamble qualifier value. The actual preamble qualifier value can be greater than 15 but since PQT_ERROR is only 4 bits wide PQT_ERROR = MIN[actual PQT qualifier value] modulo 16. This means that if PQT _ERROR = 0001b the actual preamble qualifier value is either 1 or 17. When a sync word is detected (SYNC_EVENT is asserted) the PQT_ERROR register field is not updated again before RX mode is re-entered. As long as the radio is in RX searching for a sync word the register field will be updated continuously
        pub pqt_error, _: 7, 4;

        /// Sync word qualifier value. The actual sync word qualifier value can be greater than 15 but since SYNC_ERROR is only 4 bits wide SYNC_ERROR = FLOOR[actual sync word qualifier value/2] modulo 16. This means that if SYNC_ERROR = 0001b the actual sync word qualifier value is either 2, 3, 34, or 35. When a sync word is received (SYNC_EVENT is asserted) the SYNC_ERROR register field is not updated again before RX mode is re-entered. As long as the radio is in RX searching for a sync word the register field will be updated continuously
        pub sync_error, _: 3, 0;
    }

    impl const Register for PqtSyncErr {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F75);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for PqtSyncErr {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for PqtSyncErr {
        fn default() -> Self {
            Self(0xff)
        }
    }

    impl core::fmt::Debug for PqtSyncErr {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for PqtSyncErr {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Demodulator Status
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct DemStatus(u8);

        /// RSSI step found during packet reception (after the assertion of SYNC_EVENT). The RSSI step is 10 or 16 dB and is configured through AGC_CFG1.RSSI_STEP_THR
        ///
        /// # Values
        ///
        /// - false: No RSSI step found during packet reception
        /// - true: RSSI step found during packet reception
        ///
        /// The default value is 0x00
        pub rssi_step_found, _: 7;

        /// Collision found. Asserted if a new preamble is found and the RSSI has increased 10 or 16 dB during packet reception (depending on AGC_CFG1.RSSI_STEP_THR). MDMCFG1.COLLISION_DETECT_EN must be 1
        ///
        /// # Values
        ///
        /// - false: No collision found
        /// - true: Collision found
        ///
        /// The default value is 0x00
        pub collision_found, _: 6;

        /// DualSync Detect. Only valid when SYNC_CFG0.SYNC_MODE = 111b. When SYNC_EVENT is asserted this bit can be checked to see which sync word is found
        ///
        /// # Values
        ///
        /// - false: Sync word found = [SYNC15_8:SYNC7_0]
        /// - true: Sync word found = [SYNC31_24:SYNC23_16)]
        ///
        /// The default value is 0x00
        pub sync_low0_high1, _: 5;

        /// For test purposes only, use values from SmartRF Studio.
        pub dem_status_reserved4_1, _: 4, 1;

        /// Image found detector
        ///
        /// # Values
        ///
        /// - false: No image found
        /// - true: Image found
        ///
        /// The default value is 0x00
        pub image_found, _: 0;
    }

    impl const Register for DemStatus {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F76);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for DemStatus {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for DemStatus {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for DemStatus {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for DemStatus {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Frequency Offset Estimate MSB
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct FreqoffEst1(u8);

        /// Frequency offset estimate [15:8] MSB<BR/>
        /// Frequency Offset Estimate = FREOFF_EST*f_xosc/LO Divider/2^18.0 [Hz]. The value is in two's complement format. The LO divider value can be found in FS_CFG.FSD_BANDSELECT register field
        pub freqoff_est_15_8, _: 7, 0;
    }

    impl const Register for FreqoffEst1 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F77);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for FreqoffEst1 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for FreqoffEst1 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for FreqoffEst1 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for FreqoffEst1 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Frequency Offset Estimate LSB
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct FreqoffEst0(u8);

        /// See FREQOFF_EST1
        pub freqoff_est_7_0, _: 7, 0;
    }

    impl const Register for FreqoffEst0 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F78);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for FreqoffEst0 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for FreqoffEst0 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for FreqoffEst0 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for FreqoffEst0 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Automatic Gain Control Reg. 3
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AgcGain3(u8);

        pub agc_gain3_not_used, _: 7;

        /// AGC front end gain. Actual applied gain with 1 dB resolution
        pub agc_front_end_gain, _: 6, 0;
    }

    impl const Register for AgcGain3 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F79);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AgcGain3 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AgcGain3 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for AgcGain3 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AgcGain3 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Automatic Gain Control Reg. 2
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AgcGain2(u8);

        /// Override AGC gain control
        ///
        /// # Values
        ///
        /// - true: AGC controls front end gain
        /// - false: Front end gain controlled by registers AGC_GAIN2, AGC_GAIN1, and AGC_GAIN0
        ///
        /// The default value is 0x01
        pub agc_drives_fe_gain, set_agc_drives_fe_gain: 7;

        /// For test purposes only, use values from SmartRF Studio.
        pub agc_gain2_reserved6_3, set_agc_gain2_reserved6_3: 6, 3;

        /// For test purposes only, use values from SmartRF Studio.
        pub agc_gain2_reserved2_0, set_agc_gain2_reserved2_0: 2, 0;
    }

    impl const Register for AgcGain2 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F7A);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AgcGain2 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AgcGain2 {
        fn default() -> Self {
            Self(0xd1)
        }
    }

    impl core::fmt::Debug for AgcGain2 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AgcGain2 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Automatic Gain Control Reg. 1
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AgcGain1(u8);

        pub agc_gain1_not_used, _: 7, 5;

        /// For test purposes only, use values from SmartRF Studio.
        pub agc_gain1_reserved4_3, set_agc_gain1_reserved4_3: 4, 3;

        /// For test purposes only, use values from SmartRF Studio.
        pub agc_gain1_reserved2_0, set_agc_gain1_reserved2_0: 2, 0;
    }

    impl const Register for AgcGain1 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F7B);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AgcGain1 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AgcGain1 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for AgcGain1 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AgcGain1 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Automatic Gain Control Reg. 0
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AgcGain0(u8);

        pub agc_gain0_not_used, _: 7;

        /// For test purposes only, use values from SmartRF Studio.
        pub agc_gain0_reserved6_5, set_agc_gain0_reserved6_5: 6, 5;

        /// For test purposes only, use values from SmartRF Studio.
        pub agc_gain0_reserved4_0, set_agc_gain0_reserved4_0: 4, 0;
    }

    impl const Register for AgcGain0 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F7C);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AgcGain0 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AgcGain0 {
        fn default() -> Self {
            Self(0x3f)
        }
    }

    impl core::fmt::Debug for AgcGain0 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AgcGain0 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Custom Frequency Modulation RX Data
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct CfmRxDataOut(u8);

        /// 8-bit signed soft-decision symbol data, either from normal receiver or transparent receiver. Can be read using burst mode to do custom demodulation<BR/>
        /// f_offset = f_dev*CFM_RX_DATA/64 [Hz] (two's complement format)<BR/>
        /// f_dev is the programmed frequency deviation
        pub cfm_rx_data, _: 7, 0;
    }

    impl const Register for CfmRxDataOut {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F7D);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for CfmRxDataOut {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for CfmRxDataOut {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for CfmRxDataOut {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for CfmRxDataOut {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Custom Frequency Modulation TX Data
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct CfmTxDataIn(u8);

        /// 8-bit signed soft TX data input register for custom SW controlled modulation. Can be accessed using burst mode to get arbitrary modulation<BR/>
        /// f_offset = f_dev*CFM_TX_DATA/64 [Hz] (two's complement format). f_dev is the programmed frequency deviation
        pub cfm_tx_data, set_cfm_tx_data: 7, 0;
    }

    impl const Register for CfmTxDataIn {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F7E);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for CfmTxDataIn {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for CfmTxDataIn {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for CfmTxDataIn {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for CfmTxDataIn {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// ASK Soft Decision Output
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AskSoftRxData(u8);

        pub ask_soft_not_used, _: 7, 6;

        /// The OOK/ASK receiver use a max peak magnitude tracker and low peak magnitude tracker to estimate ASK_THRESHOLD. The ASK_THRESHOLD is used to do hard decision of OOK/ASK symbols<BR/>
        /// ASK_SOFT = +16 when magnitude is = ASK_THRESHOLD<BR/>
        /// ASK_SOFT = -16 when magnitude is = ASK_THRESHOLD
        pub ask_soft, _: 5, 0;
    }

    impl const Register for AskSoftRxData {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F7F);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AskSoftRxData {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AskSoftRxData {
        fn default() -> Self {
            Self(0x30)
        }
    }

    impl core::fmt::Debug for AskSoftRxData {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AskSoftRxData {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Random Number Generator Value
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Rndgen(u8);

        /// Random number generator enable
        ///
        /// # Values
        ///
        /// - false: Random number generator disabled
        /// - true: Random number generator enabled
        ///
        /// The default value is 0x00
        pub rndgen_en, set_rndgen_en: 7;

        /// Random number value. Number generated by 7 bit LFSR register (X7+X6+1). Number will be further randomized when in RX by XORing the feedback with receiver noise
        pub rndgen_value, _: 6, 0;
    }

    impl const Register for Rndgen {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F80);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Rndgen {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Rndgen {
        fn default() -> Self {
            Self(0x7f)
        }
    }

    impl core::fmt::Debug for Rndgen {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Rndgen {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Signal Magnitude after CORDIC [16]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Magn2(u8);

        pub magn_not_used, _: 7, 1;

        /// Instantaneous signal magnitude after CORDIC, 17-bit [16]
        pub magn_16, _: 0;
    }

    impl const Register for Magn2 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F81);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Magn2 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Magn2 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for Magn2 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Magn2 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Signal Magnitude after CORDIC [15:8]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Magn1(u8);

        /// Instantaneous signal magnitude after CORDIC, 17-bit [15:8]
        pub magn_15_8, _: 7, 0;
    }

    impl const Register for Magn1 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F82);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Magn1 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Magn1 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for Magn1 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Magn1 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Signal Magnitude after CORDIC [7:0]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Magn0(u8);

        /// Instantaneous signal magnitude after CORDIC, 17-bit [7:0]
        pub magn_7_0, _: 7, 0;
    }

    impl const Register for Magn0 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F83);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Magn0 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Magn0 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for Magn0 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Magn0 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Signal Angular after CORDIC [9:8]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Ang1(u8);

        pub ang1_not_used, _: 7, 2;

        /// Instantaneous signal angular after CORDIC, 10-bit [9:8]
        pub angular_9_8, _: 1, 0;
    }

    impl const Register for Ang1 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F84);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Ang1 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Ang1 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for Ang1 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Ang1 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Signal Angular after CORDIC [7:0]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Ang0(u8);

        /// Instantaneous signal angular after CORDIC, 10-bit [7:0]
        pub angular_7_0, _: 7, 0;
    }

    impl const Register for Ang0 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F85);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Ang0 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Ang0 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for Ang0 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Ang0 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Channel Filter Data Real Part [16]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct ChfiltI2(u8);

        pub chfilt_i2_not_used, _: 7, 2;

        ///
        /// # Values
        ///
        /// - false: Channel filter data not valid
        /// - true: Channel filter data valid (asserted after 16 channel filter samples)
        ///
        /// The default value is 0x01
        pub chfilt_startup_valid, _: 1;

        /// Channel filter data, real part, 17-bit [16]
        pub chfilt_i_16, _: 0;
    }

    impl const Register for ChfiltI2 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F86);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for ChfiltI2 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for ChfiltI2 {
        fn default() -> Self {
            Self(0x02)
        }
    }

    impl core::fmt::Debug for ChfiltI2 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for ChfiltI2 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Channel Filter Data Real Part [15:8]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct ChfiltI1(u8);

        /// Channel filter data, real part, 17-bit [15:8]
        pub chfilt_i_15_8, _: 7, 0;
    }

    impl const Register for ChfiltI1 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F87);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for ChfiltI1 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for ChfiltI1 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for ChfiltI1 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for ChfiltI1 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Channel Filter Data Real Part [7:0]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct ChfiltI0(u8);

        /// Channel filter data, real part, 17-bit [7:0]
        pub chfilt_i_7_0, _: 7, 0;
    }

    impl const Register for ChfiltI0 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F88);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for ChfiltI0 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for ChfiltI0 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for ChfiltI0 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for ChfiltI0 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Channel Filter Data Imaginary Part [16]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct ChfiltQ2(u8);

        pub chfilt_q2_not_used, _: 7, 1;

        /// Channel filter data, imaginary part, 17-bit [16]
        pub chfilt_q_16, _: 0;
    }

    impl const Register for ChfiltQ2 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F89);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for ChfiltQ2 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for ChfiltQ2 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for ChfiltQ2 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for ChfiltQ2 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Channel Filter Data Imaginary Part [15:8]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct ChfiltQ1(u8);

        /// Channel filter data, imaginary part, 17-bit [15:8]
        pub chfilt_q_15_8, _: 7, 0;
    }

    impl const Register for ChfiltQ1 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F8A);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for ChfiltQ1 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for ChfiltQ1 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for ChfiltQ1 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for ChfiltQ1 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Channel Filter Data Imaginary Part [7:0]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct ChfiltQ0(u8);

        /// Channel filter data, imaginary part, 17-bit [7:0]
        pub chfilt_q_7_0, _: 7, 0;
    }

    impl const Register for ChfiltQ0 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F8B);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for ChfiltQ0 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for ChfiltQ0 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for ChfiltQ0 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for ChfiltQ0 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// General Purpose Input/Output Status
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct GpioStatus(u8);

        /// For test purposes only, use values from SmartRF Studio.
        pub gpio_status_reserved7_4, _: 7, 4;

        /// State of GPIO pins. SERIAL_STATUS.IOC_SYNC_PINS_EN must be 1
        pub gpio_state, _: 3, 0;
    }

    impl const Register for GpioStatus {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F8C);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for GpioStatus {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for GpioStatus {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for GpioStatus {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for GpioStatus {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Frequency Synthesizer Calibration Control
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct FscalCtrl(u8);

        pub fscal_ctrl_not_used, _: 7;

        /// For test purposes only, use values from SmartRF Studio.
        pub fscal_ctrl_reserved6, set_fscal_ctrl_reserved6: 6;

        /// For test purposes only, use values from SmartRF Studio.
        pub fscal_ctrl_reserved5, set_fscal_ctrl_reserved5: 5;

        /// For test purposes only, use values from SmartRF Studio.
        pub fscal_ctrl_reserved4, set_fscal_ctrl_reserved4: 4;

        /// For test purposes only, use values from SmartRF Studio.
        pub fscal_ctrl_reserved3, set_fscal_ctrl_reserved3: 3;

        /// For test purposes only, use values from SmartRF Studio.
        pub fscal_ctrl_reserved2_1, set_fscal_ctrl_reserved2_1: 2, 1;

        /// Out of lock indicator (FS_CFG.FS_LOCK_EN must be 1). The state of this signal is only valid in RX, TX, and FSTXON state
        ///
        /// # Values
        ///
        /// - false: FS is out of lock
        /// - true: FS out of lock not detected
        ///
        /// The default value is 0x01
        pub lock, _: 0;
    }

    impl const Register for FscalCtrl {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F8D);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for FscalCtrl {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for FscalCtrl {
        fn default() -> Self {
            Self(0x01)
        }
    }

    impl core::fmt::Debug for FscalCtrl {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for FscalCtrl {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Frequency Synthesizer Phase Adjust
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct PhaseAdjust(u8);

        /// For test purposes only, use values from SmartRF Studio.
        pub phase_adjust_reserved7_0, _: 7, 0;
    }

    impl const Register for PhaseAdjust {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F8E);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for PhaseAdjust {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for PhaseAdjust {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for PhaseAdjust {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for PhaseAdjust {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Part Number
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Partnumber(u8);

        /// Chip ID
        ///
        /// # Values
        ///
        /// - 0x20b: CC1200
        /// - 0x21b: CC1201
        ///
        /// The default value is 0x00
        pub partnum, _: 7, 0;
    }

    impl const Register for Partnumber {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F8F);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Partnumber {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Partnumber {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for Partnumber {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Partnumber {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Part Revision
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Partversion(u8);

        /// Chip revision
        pub partver, _: 7, 0;
    }

    impl const Register for Partversion {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F90);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Partversion {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Partversion {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for Partversion {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Partversion {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Serial Status
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct SerialStatus(u8);

        pub serial_status_not_used, _: 7, 6;

        /// Configures which memory to access when using direct memory access
        ///
        /// # Values
        ///
        /// - false: FIFO buffers
        /// - true: FEC workspace or 128 bytes free area
        ///
        /// The default value is 0x00
        pub spi_direct_access_cfg, set_spi_direct_access_cfg: 5;

        /// Internal 40 kHz RC oscillator clock
        pub clk40, _: 4;

        /// Enable synchronizer for IO pins. Required for transparent TX and for reading GPIO_STATUS.GPIO_STATE
        pub ioc_sync_pins_en, set_ioc_sync_pins_en: 3;

        /// Modulator soft data clock (16 times higher than the programmed symbol rate)
        pub cfm_tx_data_clk, _: 2;

        /// Serial RX data
        pub serial_rx, _: 1;

        /// Serial RX data clock
        pub serial_rx_clk, _: 0;
    }

    impl const Register for SerialStatus {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F91);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for SerialStatus {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for SerialStatus {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for SerialStatus {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for SerialStatus {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Modem Status Reg. 1
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct ModemStatus1(u8);

        /// Asserted simultaneously as SYNC_EVENT. De-asserted when an SRX strobe has been issued
        pub sync_found, _: 7;

        /// Asserted when number of bytes is greater than the RX FIFO threshold. De-asserted when the RX FIFO is empty
        pub rxfifo_full, _: 6;

        /// Asserted when number of bytes is greater than the RX FIFO threshold. De-asserted when the RX FIFO is drained below (or is equal) to the same threshold
        pub rxfifo_thr, _: 5;

        /// High when no bytes reside in the RX FIFO
        pub rxfifo_empty, _: 4;

        /// Asserted when the RX FIFO has overflowed (the radio has received more bytes after the RXFIFO is full). De-asserted when the RX FIFO is flushed
        pub rxfifo_overflow, _: 3;

        /// Asserted if the user try to read from an empty RX FIFO. De-asserted when the RX FIFO is flushed
        pub rxfifo_underflow, _: 2;

        /// Asserted when a preamble is detected (the preamble qualifier value is less than the programmed PQT threshold). The signal will stay asserted as long as a preamble is present but will de-assert on sync found (SYNC_EVENT asserted). If the preamble disappears, the signal will de-assert after a timeout defined by the sync word length + 10 symbols after preamble was lost
        pub pqt_reached, _: 1;

        /// Asserted after 11, 12, 13, 14,1 5, 17, 24, or 32 bits are received (depending on the PREAMBLE_CFG0.PQT_VALID_TIMEOUT setting) or after a preamble is detected
        pub pqt_valid, _: 0;
    }

    impl const Register for ModemStatus1 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F92);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for ModemStatus1 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for ModemStatus1 {
        fn default() -> Self {
            Self(0x01)
        }
    }

    impl core::fmt::Debug for ModemStatus1 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for ModemStatus1 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Modem Status Reg. 0
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct ModemStatus0(u8);

        pub modem_status0_not_used, _: 7;

        /// Internal FEC overflow has occurred
        pub feec_rx_overflow, _: 6;

        /// For test purposes only, use values from SmartRF Studio.
        pub modem_status0_reserved5, _: 5;

        /// Last bit of sync word has been sent
        pub sync_sent, _: 4;

        /// Asserted when the TX FIFO is full. De-asserted when the number of bytes is below threshold
        pub txfifo_full, _: 3;

        /// Asserted when number of bytes is greater than or equal to the TX FIFO threshold
        pub txfifo_thr, _: 2;

        /// Asserted when the TX FIFO has overflowed (The user have tried to write to a full TX FIFO). De-asserted when the TX FIFO is flushed
        pub txfifo_overflow, _: 1;

        /// Asserted when the TX FIFO has underflowed (TX FIFO is empty before the complete packet is sent). De-asserted when the TX FIFO is flushed
        pub txfifo_underflow, _: 0;
    }

    impl const Register for ModemStatus0 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F93);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for ModemStatus0 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for ModemStatus0 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for ModemStatus0 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for ModemStatus0 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// MARC Status Reg. 1
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct MarcStatus1(u8);

        /// This register should be read to find what caused the MCU_WAKEUP signal to be asserted
        ///
        /// # Values
        ///
        /// - 00000000b: No failure
        /// - 00000001b: RX timeout occurred
        /// - 00000010b: RX termination based on CS or PQT
        /// - 00000011b: eWOR sync lost (16 slots with no successful reception)
        /// - 00000100b: Packet discarded due to maximum length filtering
        /// - 00000101b: Packet discarded due to address filtering
        /// - 00000110b: Packet discarded due to CRC filtering
        /// - 00000111b: TX FIFO overflow error occurred
        /// - 00001000b: TX FIFO underflow error occurred
        /// - 00001001b: RX FIFO overflow error occurred
        /// - 00001010b: RX FIFO underflow error occurred
        /// - 00001011b: TX ON CCA failed
        /// - 01000000b: TX finished successfully
        /// - 10000000b: RX finished successfully (a packet is in the RX FIFO ready to be read)
        ///
        /// The default value is 0x00
        pub marc_status_out, _: 7, 0;
    }

    impl const Register for MarcStatus1 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F94);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for MarcStatus1 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for MarcStatus1 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for MarcStatus1 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for MarcStatus1 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// MARC Status Reg. 0
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct MarcStatus0(u8);

        pub marc_status0_not_used, _: 7, 4;

        /// For test purposes only, use values from SmartRF Studio.
        pub marc_status0_reserved3, _: 3;

        /// This bit can be read after the TXONCCA_DONE signal has been asserted
        ///
        /// # Values
        ///
        /// - false: The channel was clear. The radio will enter TX state
        /// - true: The channel was busy. The radio will remain in RX state
        ///
        /// The default value is 0x00
        pub txoncca_failed, _: 2;

        /// For test purposes only, use values from SmartRF Studio.
        pub marc_status0_reserved1, _: 1;

        /// RCOSC has been calibrated at least once
        pub rcc_cal_valid, _: 0;
    }

    impl const Register for MarcStatus0 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F95);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for MarcStatus0 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for MarcStatus0 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for MarcStatus0 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for MarcStatus0 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Power Amplifier Intermediate Frequency Amplifier Test
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct PaIfampTest(u8);

        pub pa_ifamp_test_not_used, _: 7, 5;

        /// For test purposes only, use values from SmartRF Studio.
        pub pa_ifamp_test_reserved4, set_pa_ifamp_test_reserved4: 4;

        /// For test purposes only, use values from SmartRF Studio.
        pub pa_ifamp_test_reserved3, set_pa_ifamp_test_reserved3: 3;

        /// For test purposes only, use values from SmartRF Studio.
        pub pa_ifamp_test_reserved2, set_pa_ifamp_test_reserved2: 2;

        /// For test purposes only, use values from SmartRF Studio.
        pub pa_ifamp_test_reserved1, set_pa_ifamp_test_reserved1: 1;

        /// For test purposes only, use values from SmartRF Studio.
        pub pa_ifamp_test_reserved0, set_pa_ifamp_test_reserved0: 0;
    }

    impl const Register for PaIfampTest {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F96);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for PaIfampTest {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for PaIfampTest {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for PaIfampTest {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for PaIfampTest {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Frequency Synthesizer Test
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct FsrfTest(u8);

        pub fsrf_test_not_used, _: 7;

        /// For test purposes only, use values from SmartRF Studio.
        pub fsrf_test_reserved6, set_fsrf_test_reserved6: 6;

        /// For test purposes only, use values from SmartRF Studio.
        pub fsrf_test_reserved5_4, set_fsrf_test_reserved5_4: 5, 4;

        /// For test purposes only, use values from SmartRF Studio.
        pub fsrf_test_reserved3, set_fsrf_test_reserved3: 3;

        /// For test purposes only, use values from SmartRF Studio.
        pub fsrf_test_reserved2_0, set_fsrf_test_reserved2_0: 2, 0;
    }

    impl const Register for FsrfTest {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F97);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for FsrfTest {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for FsrfTest {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for FsrfTest {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for FsrfTest {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Frequency Synthesizer Prescaler Test
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct PreTest(u8);

        pub pre_test_not_used, _: 7, 5;

        /// For test purposes only, use values from SmartRF Studio.
        pub pre_test_reserved4, set_pre_test_reserved4: 4;

        /// For test purposes only, use values from SmartRF Studio.
        pub pre_test_reserved3_0, set_pre_test_reserved3_0: 3, 0;
    }

    impl const Register for PreTest {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F98);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for PreTest {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for PreTest {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for PreTest {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for PreTest {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Frequency Synthesizer Prescaler Override
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct PreOvr(u8);

        /// For test purposes only, use values from SmartRF Studio.
        pub pre_ovr_reserved7_4, set_pre_ovr_reserved7_4: 7, 4;

        /// For test purposes only, use values from SmartRF Studio.
        pub pre_ovr_reserved3_0, set_pre_ovr_reserved3_0: 3, 0;
    }

    impl const Register for PreOvr {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F99);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for PreOvr {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for PreOvr {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for PreOvr {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for PreOvr {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Analog to Digital Converter Test
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AdcTest(u8);

        pub adc_test_not_used, _: 7, 6;

        /// For test purposes only, use values from SmartRF Studio.
        pub adc_test_reserved5, set_adc_test_reserved5: 5;

        /// For test purposes only, use values from SmartRF Studio.
        pub adc_test_reserved4_0, set_adc_test_reserved4_0: 4, 0;
    }

    impl const Register for AdcTest {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F9A);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AdcTest {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AdcTest {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for AdcTest {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AdcTest {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Digital Divider Chain Test
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct DvcTest(u8);

        pub dvc_test_not_used, _: 7, 5;

        /// For test purposes only, use values from SmartRF Studio.
        pub dvc_test_reserved4_0, set_dvc_test_reserved4_0: 4, 0;
    }

    impl const Register for DvcTest {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F9B);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for DvcTest {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for DvcTest {
        fn default() -> Self {
            Self(0x0b)
        }
    }

    impl core::fmt::Debug for DvcTest {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for DvcTest {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Analog Test
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Atest(u8);

        pub atest_not_used, _: 7;

        /// For test purposes only, use values from SmartRF Studio.
        pub atest_reserved6, set_atest_reserved6: 6;

        /// For test purposes only, use values from SmartRF Studio.
        pub atest_reserved5_0, set_atest_reserved5_0: 5, 0;
    }

    impl const Register for Atest {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F9C);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Atest {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Atest {
        fn default() -> Self {
            Self(0x40)
        }
    }

    impl core::fmt::Debug for Atest {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Atest {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Analog Test LVDS
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AtestLvds(u8);

        pub atest_lvds_not_used, _: 7, 6;

        /// For test purposes only, use values from SmartRF Studio.
        pub atest_lvds_reserved5_4, set_atest_lvds_reserved5_4: 5, 4;

        /// For test purposes only, use values from SmartRF Studio.
        pub atest_lvds_reserved3_0, set_atest_lvds_reserved3_0: 3, 0;
    }

    impl const Register for AtestLvds {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F9D);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AtestLvds {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AtestLvds {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for AtestLvds {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AtestLvds {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Analog Test Mode
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AtestMode(u8);

        /// For test purposes only, use values from SmartRF Studio.
        pub atest_mode_reserved7_4, set_atest_mode_reserved7_4: 7, 4;

        /// For test purposes only, use values from SmartRF Studio.
        pub atest_mode_reserved3_0, set_atest_mode_reserved3_0: 3, 0;
    }

    impl const Register for AtestMode {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F9E);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AtestMode {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AtestMode {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for AtestMode {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AtestMode {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Crystal Oscillator Test Reg. 1
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct XoscTest1(u8);

        /// For test purposes only, use values from SmartRF Studio.
        pub xosc_test1_reserved7, set_xosc_test1_reserved7: 7;

        /// For test purposes only, use values from SmartRF Studio.
        pub xosc_test1_reserved6, set_xosc_test1_reserved6: 6;

        /// For test purposes only, use values from SmartRF Studio.
        pub xosc_test1_reserved5_2, _: 5, 2;

        /// For test purposes only, use values from SmartRF Studio.
        pub xosc_test1_reserved1_0, set_xosc_test1_reserved1_0: 1, 0;
    }

    impl const Register for XoscTest1 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2F9F);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for XoscTest1 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for XoscTest1 {
        fn default() -> Self {
            Self(0x3c)
        }
    }

    impl core::fmt::Debug for XoscTest1 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for XoscTest1 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Crystal Oscillator Test Reg. 0
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct XoscTest0(u8);

        /// For test purposes only, use values from SmartRF Studio.
        pub xosc_test0_reserved7_0, set_xosc_test0_reserved7_0: 7, 0;
    }

    impl const Register for XoscTest0 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FA0);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for XoscTest0 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for XoscTest0 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for XoscTest0 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for XoscTest0 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// AES
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Aes(u8);

        pub aes_not_used, _: 7, 2;

        /// Setting this bit to 1 will abort the AES encryption cycle. The bit will be cleared by HW when the abortion sequence is completed
        pub aes_abort, set_aes_abort: 1;

        /// AES enable. The bit will be cleared by HW when an encryption cycle has finished
        ///
        /// # Values
        ///
        /// - false: Halt the current AES encryption
        /// - true: AES module is enabled and the AES encryption cycle will start/continue given that AES_ABORT is low
        ///
        /// The default value is 0x00
        pub aes_run, set_aes_run: 0;
    }

    impl const Register for Aes {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FA1);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Aes {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Aes {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for Aes {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Aes {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// MODEM Test
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct MdmTest(u8);

        pub mdm_test_not_used, _: 7, 4;

        /// For test purposes only, use values from SmartRF Studio.
        pub mdm_test_reserved3_0, set_mdm_test_reserved3_0: 3, 0;
    }

    impl const Register for MdmTest {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FA2);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for MdmTest {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for MdmTest {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for MdmTest {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for MdmTest {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// RX FIFO Pointer First Entry
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Rxfirst(u8);

        /// Pointer to the first entry in the RX FIFO
        pub rx_first, set_rx_first: 7, 0;
    }

    impl const Register for Rxfirst {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FD2);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Rxfirst {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Rxfirst {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for Rxfirst {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Rxfirst {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// TX FIFO Pointer First Entry
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Txfirst(u8);

        /// Pointer to the first entry in the TX FIFO
        pub tx_first, set_tx_first: 7, 0;
    }

    impl const Register for Txfirst {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FD3);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Txfirst {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Txfirst {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for Txfirst {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Txfirst {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// RX FIFO Pointer Last Entry
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Rxlast(u8);

        /// Pointer to the last entry in the RX FIFO
        pub rx_last, set_rx_last: 7, 0;
    }

    impl const Register for Rxlast {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FD4);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Rxlast {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Rxlast {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for Rxlast {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Rxlast {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// TX FIFO Pointer Last Entry
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct Txlast(u8);

        /// Pointer to the last entry in the TX FIFO
        pub tx_last, set_tx_last: 7, 0;
    }

    impl const Register for Txlast {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FD5);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for Txlast {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for Txlast {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for Txlast {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for Txlast {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// TX FIFO Status
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct NumTxbytes(u8);

        /// Number of bytes in the TX FIFO
        pub txbytes, _: 7, 0;
    }

    impl const Register for NumTxbytes {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FD6);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for NumTxbytes {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for NumTxbytes {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for NumTxbytes {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for NumTxbytes {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// RX FIFO Status
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct NumRxbytes(u8);

        /// Number of bytes in the RX FIFO
        pub rxbytes, _: 7, 0;
    }

    impl const Register for NumRxbytes {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FD7);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for NumRxbytes {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for NumRxbytes {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for NumRxbytes {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for NumRxbytes {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// TX FIFO Status
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct FifoNumTxbytes(u8);

        pub fifo_num_txbytes_not_used, _: 7, 4;

        /// Number of free entries in the TX FIFO. 1111b means that there are 15 or more free entries
        pub fifo_txbytes, _: 3, 0;
    }

    impl const Register for FifoNumTxbytes {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FD8);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for FifoNumTxbytes {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for FifoNumTxbytes {
        fn default() -> Self {
            Self(0x0f)
        }
    }

    impl core::fmt::Debug for FifoNumTxbytes {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for FifoNumTxbytes {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// RX FIFO Status
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct FifoNumRxbytes(u8);

        pub fifo_num_rxbytes_not_used, _: 7, 4;

        /// Number of available bytes in the RX FIFO. 1111b means that there are 15 or more bytes available to read
        pub fifo_rxbytes, _: 3, 0;
    }

    impl const Register for FifoNumRxbytes {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FD9);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for FifoNumRxbytes {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for FifoNumRxbytes {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for FifoNumRxbytes {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for FifoNumRxbytes {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// RX FIFO Status
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct RxfifoPreBuf(u8);

        /// Contains the first byte received in the RX FIFO when the RX FIFO is empty (i.e. RXFIRST = RXLAST)
        pub pre_buf, _: 7, 0;
    }

    impl const Register for RxfifoPreBuf {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FDA);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for RxfifoPreBuf {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for RxfifoPreBuf {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for RxfifoPreBuf {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for RxfifoPreBuf {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Advanced Encryption Standard Key [127:120]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AesKey15(u8);

        /// 16 bytes AES key, [127:120]
        pub aes_key_127_120, set_aes_key_127_120: 7, 0;
    }

    impl const Register for AesKey15 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FE0);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AesKey15 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AesKey15 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for AesKey15 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AesKey15 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Advanced Encryption Standard Key [119:112]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AesKey14(u8);

        /// 16 bytes AES key, [119:112]
        pub aes_key_119_112, set_aes_key_119_112: 7, 0;
    }

    impl const Register for AesKey14 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FE1);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AesKey14 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AesKey14 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for AesKey14 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AesKey14 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Advanced Encryption Standard Key [111:104]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AesKey13(u8);

        /// 16 bytes AES key, [111:104]
        pub aes_key_111_104, set_aes_key_111_104: 7, 0;
    }

    impl const Register for AesKey13 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FE2);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AesKey13 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AesKey13 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for AesKey13 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AesKey13 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Advanced Encryption Standard Key [103:96]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AesKey12(u8);

        /// 16 bytes AES key, [103:96]
        pub aes_key_103_96, set_aes_key_103_96: 7, 0;
    }

    impl const Register for AesKey12 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FE3);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AesKey12 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AesKey12 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for AesKey12 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AesKey12 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Advanced Encryption Standard Key [95:88]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AesKey11(u8);

        /// 16 bytes AES key, [95:88]
        pub aes_key_95_88, set_aes_key_95_88: 7, 0;
    }

    impl const Register for AesKey11 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FE4);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AesKey11 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AesKey11 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for AesKey11 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AesKey11 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Advanced Encryption Standard Key [87:80]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AesKey10(u8);

        /// 16 bytes AES key, [87:80]
        pub aes_key_87_80, set_aes_key_87_80: 7, 0;
    }

    impl const Register for AesKey10 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FE5);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AesKey10 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AesKey10 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for AesKey10 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AesKey10 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Advanced Encryption Standard Key [79:72]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AesKey9(u8);

        /// 16 bytes AES key, [79:72]
        pub aes_key_79_72, set_aes_key_79_72: 7, 0;
    }

    impl const Register for AesKey9 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FE6);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AesKey9 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AesKey9 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for AesKey9 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AesKey9 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Advanced Encryption Standard Key [71:64]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AesKey8(u8);

        /// 16 bytes AES key, [71:64]
        pub aes_key_71_64, set_aes_key_71_64: 7, 0;
    }

    impl const Register for AesKey8 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FE7);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AesKey8 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AesKey8 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for AesKey8 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AesKey8 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Advanced Encryption Standard Key [63:56]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AesKey7(u8);

        /// 16 bytes AES key, [63:56]
        pub aes_key_63_56, set_aes_key_63_56: 7, 0;
    }

    impl const Register for AesKey7 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FE8);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AesKey7 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AesKey7 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for AesKey7 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AesKey7 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Advanced Encryption Standard Key [55:48]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AesKey6(u8);

        /// 16 bytes AES key, [55:48]
        pub aes_key_55_48, set_aes_key_55_48: 7, 0;
    }

    impl const Register for AesKey6 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FE9);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AesKey6 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AesKey6 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for AesKey6 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AesKey6 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Advanced Encryption Standard Key [47:40]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AesKey5(u8);

        /// 16 bytes AES key, [47:40]
        pub aes_key_47_40, set_aes_key_47_40: 7, 0;
    }

    impl const Register for AesKey5 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FEA);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AesKey5 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AesKey5 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for AesKey5 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AesKey5 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Advanced Encryption Standard Key [39:32]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AesKey4(u8);

        /// 16 bytes AES key, [39:32]
        pub aes_key_39_32, set_aes_key_39_32: 7, 0;
    }

    impl const Register for AesKey4 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FEB);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AesKey4 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AesKey4 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for AesKey4 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AesKey4 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Advanced Encryption Standard Key [31:24]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AesKey3(u8);

        /// 16 bytes AES key, [31:24]
        pub aes_key_31_24, set_aes_key_31_24: 7, 0;
    }

    impl const Register for AesKey3 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FEC);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AesKey3 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AesKey3 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for AesKey3 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AesKey3 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Advanced Encryption Standard Key [23:16]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AesKey2(u8);

        /// 16 bytes AES key, [23:16]
        pub aes_key_23_16, set_aes_key_23_16: 7, 0;
    }

    impl const Register for AesKey2 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FED);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AesKey2 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AesKey2 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for AesKey2 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AesKey2 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Advanced Encryption Standard Key [15:8]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AesKey1(u8);

        /// 16 bytes AES key, [15:8]
        pub aes_key_15_8, set_aes_key_15_8: 7, 0;
    }

    impl const Register for AesKey1 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FEE);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AesKey1 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AesKey1 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for AesKey1 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AesKey1 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Advanced Encryption Standard Key [7:0]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AesKey0(u8);

        /// 16 bytes AES key, [7:0]
        pub aes_key_7_0, set_aes_key_7_0: 7, 0;
    }

    impl const Register for AesKey0 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FEF);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AesKey0 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AesKey0 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for AesKey0 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AesKey0 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Advanced Encryption Standard Buffer [127:120]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AesBuffer15(u8);

        /// AES data buffer [127:120]. The content serves as input to the AES encryption module, and the content will be overwritten with the encrypted data when the AES encryption is completed
        pub aes_buffer_127_120, set_aes_buffer_127_120: 7, 0;
    }

    impl const Register for AesBuffer15 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FF0);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AesBuffer15 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AesBuffer15 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for AesBuffer15 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AesBuffer15 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Advanced Encryption Standard Buffer [119:112]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AesBuffer14(u8);

        /// AES data buffer [119:112]. See AES_BUFFER15 for details
        pub aes_buffer_119_112, set_aes_buffer_119_112: 7, 0;
    }

    impl const Register for AesBuffer14 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FF1);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AesBuffer14 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AesBuffer14 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for AesBuffer14 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AesBuffer14 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Advanced Encryption Standard Buffer [111:104]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AesBuffer13(u8);

        /// AES data buffer [111:104]. See AES_BUFFER15 for details
        pub aes_buffer_111_104, set_aes_buffer_111_104: 7, 0;
    }

    impl const Register for AesBuffer13 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FF2);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AesBuffer13 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AesBuffer13 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for AesBuffer13 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AesBuffer13 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Advanced Encryption Standard Buffer [103:93]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AesBuffer12(u8);

        /// AES data buffer [103:93]. See AES_BUFFER15 for details
        pub aes_buffer_103_93, set_aes_buffer_103_93: 7, 0;
    }

    impl const Register for AesBuffer12 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FF3);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AesBuffer12 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AesBuffer12 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for AesBuffer12 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AesBuffer12 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Advanced Encryption Standard Buffer [95:88]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AesBuffer11(u8);

        /// AES data buffer [95:88]. See AES_BUFFER15 for details
        pub aes_buffer_95_88, set_aes_buffer_95_88: 7, 0;
    }

    impl const Register for AesBuffer11 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FF4);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AesBuffer11 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AesBuffer11 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for AesBuffer11 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AesBuffer11 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Advanced Encryption Standard Buffer [87:80]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AesBuffer10(u8);

        /// AES data buffer [87:80]. See AES_BUFFER15 for details
        pub aes_buffer_87_80, set_aes_buffer_87_80: 7, 0;
    }

    impl const Register for AesBuffer10 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FF5);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AesBuffer10 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AesBuffer10 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for AesBuffer10 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AesBuffer10 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Advanced Encryption Standard Buffer [79:72]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AesBuffer9(u8);

        /// AES data buffer [79:72]. See AES_BUFFER15 for details
        pub aes_buffer_79_72, set_aes_buffer_79_72: 7, 0;
    }

    impl const Register for AesBuffer9 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FF6);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AesBuffer9 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AesBuffer9 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for AesBuffer9 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AesBuffer9 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Advanced Encryption Standard Buffer [71:64]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AesBuffer8(u8);

        /// AES data buffer [71:64]. See AES_BUFFER15 for details
        pub aes_buffer_71_64, set_aes_buffer_71_64: 7, 0;
    }

    impl const Register for AesBuffer8 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FF7);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AesBuffer8 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AesBuffer8 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for AesBuffer8 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AesBuffer8 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Advanced Encryption Standard Buffer [63:56]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AesBuffer7(u8);

        /// AES data buffer [63:56]. See AES_BUFFER15 for details
        pub aes_buffer_63_56, set_aes_buffer_63_56: 7, 0;
    }

    impl const Register for AesBuffer7 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FF8);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AesBuffer7 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AesBuffer7 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for AesBuffer7 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AesBuffer7 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Advanced Encryption Standard Buffer [55:48]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AesBuffer6(u8);

        /// AES data buffer [55:48]. See AES_BUFFER15 for details
        pub aes_buffer_55_48, set_aes_buffer_55_48: 7, 0;
    }

    impl const Register for AesBuffer6 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FF9);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AesBuffer6 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AesBuffer6 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for AesBuffer6 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AesBuffer6 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Advanced Encryption Standard Buffer [47:40]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AesBuffer5(u8);

        /// AES data buffer [47:40]. See AES_BUFFER15 for details
        pub aes_buffer_47_40, set_aes_buffer_47_40: 7, 0;
    }

    impl const Register for AesBuffer5 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FFA);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AesBuffer5 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AesBuffer5 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for AesBuffer5 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AesBuffer5 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Advanced Encryption Standard Buffer [39:32]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AesBuffer4(u8);

        /// AES data buffer [39:32]. See AES_BUFFER15 for details
        pub aes_buffer_39_32, set_aes_buffer_39_32: 7, 0;
    }

    impl const Register for AesBuffer4 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FFB);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AesBuffer4 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AesBuffer4 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for AesBuffer4 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AesBuffer4 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Advanced Encryption Standard Buffer [31:24]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AesBuffer3(u8);

        /// AES data buffer [131:24]. See AES_BUFFER15 for details
        pub aes_buffer_31_24, set_aes_buffer_31_24: 7, 0;
    }

    impl const Register for AesBuffer3 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FFC);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AesBuffer3 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AesBuffer3 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for AesBuffer3 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AesBuffer3 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Advanced Encryption Standard Buffer [23:16]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AesBuffer2(u8);

        /// AES data buffer [23:16]. See AES_BUFFER15 for details
        pub aes_buffer_23_16, set_aes_buffer_23_16: 7, 0;
    }

    impl const Register for AesBuffer2 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FFD);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AesBuffer2 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AesBuffer2 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for AesBuffer2 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AesBuffer2 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Advanced Encryption Standard Buffer [15:8]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AesBuffer1(u8);

        /// AES data buffer [15:8]. See AES_BUFFER15 for details
        pub aes_buffer_15_8, set_aes_buffer_15_8: 7, 0;
    }

    impl const Register for AesBuffer1 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FFE);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AesBuffer1 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AesBuffer1 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for AesBuffer1 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AesBuffer1 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }

    bitfield! {
        /// Advanced Encryption Standard Buffer [7:0]
        ///
        #[derive(Clone, Copy, PartialEq)]
        pub struct AesBuffer0(u8);

        /// AES data buffer [7:0]. See AES_BUFFER15 for details
        pub aes_buffer_7_0, set_aes_buffer_7_0: 7, 0;
    }

    impl const Register for AesBuffer0 {
        const ADDRESS: RegisterAddress = RegisterAddress(0x2FFF);

        fn value(&self) -> u8 {
            self.0
        }
    }

    impl From<u8> for AesBuffer0 {
        fn from(value: u8) -> Self {
            Self(value)
        }
    }

    impl Default for AesBuffer0 {
        fn default() -> Self {
            Self(0x00)
        }
    }

    impl core::fmt::Debug for AesBuffer0 {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            write!(f, "0x{:02x}", self.0)
        }
    }

    #[cfg(feature = "defmt")]
    impl defmt::Format for AesBuffer0 {
        fn format(&self, fmt: defmt::Formatter) {
            defmt::write!(fmt, "0x{:02x}", self.0);
        }
    }
}
